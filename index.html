<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Mitchell Photo App</title>

  <meta name="theme-color" content="#0f172a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Mitchell Photos">

  <style>
    :root{
      --bg:#0b1020;
      --panel: rgba(18,28,55,.78);
      --border: rgba(255,255,255,.12);
      --text:#eef2ff;
      --muted:#a7b1d8;
      --primary:#3b82f6;
      --danger:#ef4444;
      --ok:#22c55e;
      --radius:14px;
      --shadow: 0 14px 34px rgba(0,0,0,.40);
      --safe-b: env(safe-area-inset-bottom, 0px);
      --safe-t: env(safe-area-inset-top, 0px);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, #1a2a66 0%, rgba(26,42,102,0) 55%),
        radial-gradient(900px 700px at 80% 0%, #173a7a 0%, rgba(23,58,122,0) 60%),
        var(--bg);
      overflow:hidden;
      padding-top: var(--safe-t);
    }

    header{
      padding: 14px 14px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    h1{ margin:0; font-size:16px; font-weight:900; letter-spacing:.2px; }
    .muted{ color:var(--muted); font-size:12px; }

    main{
      height: calc(100% - 58px);
      overflow:auto;
      padding: 0 14px calc(18px + var(--safe-b)) 14px;
      -webkit-overflow-scrolling: touch;
    }

    .card{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .grow{ flex: 1 1 220px; min-width:200px; }

    select, textarea, button, input{ font:inherit; }
    select, textarea{
      width:100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,16,34,.55);
      color: var(--text);
      outline:none;
    }
    textarea{ min-height: 86px; resize: vertical; }

    .btn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
    }
    .btn.primary{ background: rgba(59,130,246,.20); border-color: rgba(59,130,246,.35); }
    .btn.danger{ background: rgba(239,68,68,.20); border-color: rgba(239,68,68,.35); }
    .btn.ok{ background: rgba(34,197,94,.18); border-color: rgba(34,197,94,.35); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    .btn.sm{
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 1000;
    }

    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight: 900;
      font-size:12px;
      color: var(--muted);
      user-select:none;
    }

    .drop{
      border:2px dashed rgba(255,255,255,.16);
      border-radius: var(--radius);
      padding: 12px;
      text-align:center;
      background: rgba(0,0,0,.10);
    }
    .drop.drag{
      border-color: rgba(59,130,246,.85);
      background: rgba(59,130,246,.10);
    }

    .grid{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
    }
    @media (max-width: 1100px){ .grid{ grid-template-columns: repeat(4, 1fr); } }
    @media (max-width: 820px){ .grid{ grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 520px){ .grid{ grid-template-columns: repeat(2, 1fr); } }

    .thumb{
      position:relative;
      border-radius: 14px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      aspect-ratio: 1 / 1;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
      touch-action: none; /* needed for custom drag on mobile */
    }
    .thumb img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }
    .tagbar{
      position:absolute;
      left:8px; right:8px; bottom:8px;
      display:flex; flex-wrap:wrap; gap:6px;
      pointer-events:none;
    }
    .chip{
      font-size:11px;
      padding: 5px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(12,18,38,.65);
      backdrop-filter: blur(10px);
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* number badge */
    .num{
      position:absolute;
      top:8px; left:8px;
      width:auto;
      padding: 6px 9px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 1000;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }

    /* reorder insert indicator */
    .insertLine{
      position:absolute;
      top:0; bottom:0;
      width: 0;
      border-left: 3px solid rgba(59,130,246,.95);
      filter: drop-shadow(0 0 10px rgba(59,130,246,.35));
      pointer-events:none;
      display:none;
      z-index: 5;
    }
    .insertBadge{
      position:absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 1000;
      font-size: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.55);
      pointer-events:none;
      display:none;
      z-index: 6;
      max-width: 92vw;
      white-space: nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* Viewer / Markup */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.72);
      backdrop-filter: blur(10px);
      z-index: 50;
      display:none;
    }
    .overlay.show{ display:block; }

    .viewer{
      position:absolute;
      inset: 10px 10px 10px 10px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(12,18,38,.92);
      box-shadow: var(--shadow);
      display:flex;
      overflow:hidden;
    }
    .vLeft{
      flex: 1.5;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.18);
      min-width:0;
      touch-action: none;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }
    .vRight{
      flex: 0.8;
      border-left:1px solid rgba(255,255,255,.10);
      padding:12px;
      overflow:auto;
      min-width: 300px;
    }
    @media (max-width: 950px){
      .viewer{ flex-direction:column; }
      .vRight{ border-left:none; border-top:1px solid rgba(255,255,255,.10); min-width:0; }
    }

    .topbar{
      position:absolute;
      top:10px; left:10px; right:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
      z-index: 10;
    }
    .topbar .group{ display:flex; gap:10px; pointer-events:auto; }

    .iconBtn{
      width:44px; height:44px;
      display:inline-flex; align-items:center; justify-content:center;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      font-weight: 1000;
      cursor:pointer;
      user-select:none;
    }

    /* Big side arrows */
    .arrow{
      position:absolute;
      top:50%;
      transform: translateY(-50%);
      width:54px; height:54px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 24px;
      font-weight: 1000;
      cursor:pointer;
      user-select:none;
      pointer-events:auto;
      z-index: 10;
    }
    .arrow.left{ left:10px; }
    .arrow.right{ right:10px; }
    .arrow[aria-disabled="true"]{ opacity:.4; cursor:not-allowed; }

    .toolbar{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top: 10px;
    }
    .toolbtn{
      padding: 9px 10px;
      border-radius: 12px;
      font-weight: 1000;
      font-size: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      cursor:pointer;
      user-select:none;
    }
    .toolbtn.active{
      background: rgba(59,130,246,.22);
      border-color: rgba(59,130,246,.40);
    }

    .toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom: calc(16px + var(--safe-b));
      background: rgba(0,0,0,.65);
      border:1px solid rgba(255,255,255,.12);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight:1000;
      font-size:12px;
      z-index: 60;
      display:none;
      max-width: 92vw;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .toast.show{ display:block; }

    .small{ font-size:12px; color: var(--muted); }
    .hr{ height:1px; background: rgba(255,255,255,.10); margin: 10px 0; }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Mitchell Photo App</h1>
      <div class="muted">Numbered ‚Ä¢ Drag reorder ‚Ä¢ Markup tools ‚Ä¢ Offline</div>
    </div>
    <div class="pill"><span id="count">0</span> photos</div>
  </header>

  <main>
    <div class="card" style="margin-bottom:12px;">
      <div class="row" style="margin-bottom:10px;">
        <label class="btn primary" style="display:inline-flex; align-items:center; gap:8px;">
          üì∑ Add Photos
          <input id="fileInput" type="file" accept="image/*" multiple hidden>
        </label>

        <label class="btn" style="display:inline-flex; align-items:center; gap:8px;">
          üì∏ Camera
          <input id="camInput" type="file" accept="image/*" capture="environment" hidden>
        </label>

        <button class="btn" id="exportCsv">Export CSV</button>
        <button class="btn danger" id="wipeAll" title="Clears this device only">Wipe</button>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <div class="grow">
          <div class="small">Default Folder (new photos)</div>
          <select id="folderSel"></select>
        </div>
        <div class="grow">
          <div class="small">Default Category (new photos)</div>
          <select id="catSel"></select>
        </div>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <div class="grow">
          <div class="small">Tip</div>
          <div class="small">
            Drag a photo to reorder. While dragging, you'll see <b>BEFORE / AFTER</b> to know if it‚Äôs going in front or behind.
          </div>
        </div>
        <div class="grow">
          <div class="small">Snap angles</div>
          <div class="row">
            <button class="btn sm" id="snapToggle">Snap: OFF</button>
            <div class="small">Helps straight-edge / angles. (Desktop: hold Shift)</div>
          </div>
        </div>
      </div>

      <div class="drop" id="dropZone">
        <b>Drag & drop photos here</b>
        <div class="small">Saved offline on this device. Tap a photo to view & markup.</div>
      </div>
    </div>

    <div class="insertBadge" id="insertBadge"></div>
    <div id="grid" class="grid"></div>
    <div id="empty" class="muted" style="text-align:center; padding: 22px 0; display:none;">
      No photos yet. Add some above.
    </div>
  </main>

  <!-- Viewer -->
  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="viewer">
      <div class="vLeft" id="vLeft">
        <div class="topbar">
          <div class="group">
            <button class="iconBtn" id="closeBtn" title="Close">‚úï</button>
            <div class="pill" id="posPill">0 / 0</div>
          </div>
          <div class="group">
            <button class="iconBtn" id="prevBtn" title="Prev">‚Üê</button>
            <button class="iconBtn" id="nextBtn" title="Next">‚Üí</button>
          </div>
        </div>

        <div class="arrow left" id="bigPrev" aria-disabled="false">‚Äπ</div>
        <div class="arrow right" id="bigNext" aria-disabled="false">‚Ä∫</div>

        <canvas id="canvas"></canvas>
      </div>

      <div class="vRight">
        <div style="font-weight:1000; margin-bottom:6px;">Photo</div>
        <div class="small" id="fileName">‚Äî</div>

        <div class="hr"></div>

        <div class="small">Folder</div>
        <select id="vFolder"></select>

        <div style="height:10px;"></div>

        <div class="small">Category</div>
        <select id="vCat"></select>

        <div style="height:10px;"></div>

        <div class="small">Notes</div>
        <textarea id="vNotes" placeholder="Damage notes, parts notes, etc."></textarea>

        <div class="hr"></div>

        <div style="font-weight:1000;">Markup tools</div>
        <div class="toolbar" id="toolbar">
          <button class="toolbtn" data-tool="arrow">Arrow</button>
          <button class="toolbtn" data-tool="circle">Circle</button>
          <button class="toolbtn" data-tool="rect">Square</button>
          <button class="toolbtn" data-tool="line">Straight Edge</button>
          <button class="toolbtn" data-tool="angle">Line Angle</button>
          <button class="toolbtn" data-tool="ruler">Measure</button>
          <button class="toolbtn" data-tool="pan">Pan</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn sm" id="undoBtn">Undo</button>
          <button class="btn sm" id="clearBtn">Clear</button>
          <button class="btn sm" id="resetViewBtn">Reset View</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn primary" id="saveBtn">Save</button>
          <button class="btn danger" id="delBtn">Delete</button>
        </div>

        <div class="small" style="margin-top:10px;">
          Tips: drag to pan (Pan tool) ‚Ä¢ pinch-zoom on iPhone/iPad works via browser zoom ‚Ä¢ Arrow keys ‚Üê/‚Üí ‚Ä¢ Esc closes
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  // =======================
  // IndexedDB
  // =======================
  const DB_NAME = "mitchell_photo_app_full_v1";
  const DB_VER = 1;
  const STORE_PHOTOS = "photos"; // {id, blob, type}
  const STORE_META   = "meta";   // {id, filename, created, folder, category, notes, order, anno}

  const FOLDERS = ["Unsorted","RO","Tear Down","Supplements","After Repair","Final"];
  const CATS    = ["Uncategorized","VIN","Odometer","Front","Rear","Left Side","Right Side","Damage","Repair Area","Parts"];

  let db;
  let meta = [];     // array of meta records sorted by order
  let viewerIndex = -1;

  // Drag reorder state
  let dragging = null;   // {id, startIndex, ghost, offsetX, offsetY}
  let insertTarget = null; // {index, side:'before'|'after'}
  let snapAngles = false;

  // Viewer / canvas state
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  let imgBitmap = null;        // ImageBitmap for current photo
  let view = { scale: 1, tx: 0, ty: 0 };  // simple pan/scale
  let tool = "arrow";
  let isDown = false;
  let start = {x:0,y:0};
  let curr = {x:0,y:0};
  let temp = null;
  let anno = [];      // current photo annotations (array of shapes)
  let undoStack = []; // for current photo

  // Colors & stroke
  const STROKE = "rgba(0,255,0,0.95)";
  const STROKE2 = "rgba(0,0,0,0.55)";
  const WIDTH = 4;

  // =======================
  // Helpers
  // =======================
  const $ = (s) => document.querySelector(s);
  const toastEl = $("#toast");
  let toastTimer = null;

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toastEl.classList.remove("show"), 1800);
  }

  function uuid(){
    return crypto.randomUUID ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2) + Date.now());
  }
  function nowISO(){ return new Date().toISOString(); }

  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VER);
      req.onerror = () => reject(req.error);
      req.onupgradeneeded = () => {
        const d = req.result;
        if (!d.objectStoreNames.contains(STORE_PHOTOS)) d.createObjectStore(STORE_PHOTOS, {keyPath:"id"});
        if (!d.objectStoreNames.contains(STORE_META))   d.createObjectStore(STORE_META,   {keyPath:"id"});
      };
      req.onsuccess = () => resolve(req.result);
    });
  }
  function tx(stores, mode="readonly"){ return db.transaction(stores, mode); }

  function idbGet(store, key){
    return new Promise((resolve, reject) => {
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function idbPut(store, val){
    return new Promise((resolve, reject) => {
      const req = store.put(val);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function idbDel(store, key){
    return new Promise((resolve, reject) => {
      const req = store.delete(key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }
  function idbGetAll(store){
    return new Promise((resolve, reject) => {
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  }
  function waitTxDone(t){
    return new Promise((resolve, reject) => {
      t.oncomplete = () => resolve(true);
      t.onerror = () => reject(t.error);
      t.onabort = () => reject(t.error || new Error("tx aborted"));
    });
  }

  function buildSelects(){
    $("#folderSel").innerHTML = FOLDERS.map(f => `<option value="${esc(f)}">${esc(f)}</option>`).join("");
    $("#catSel").innerHTML = CATS.map(c => `<option value="${esc(c)}">${esc(c)}</option>`).join("");
    $("#vFolder").innerHTML = FOLDERS.map(f => `<option value="${esc(f)}">${esc(f)}</option>`).join("");
    $("#vCat").innerHTML = CATS.map(c => `<option value="${esc(c)}">${esc(c)}</option>`).join("");
    $("#folderSel").value = "Unsorted";
    $("#catSel").value = "Uncategorized";
  }
  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  // =======================
  // Load / Save meta
  // =======================
  async function loadMeta(){
    const all = await idbGetAll(tx([STORE_META], "readonly").objectStore(STORE_META));
    meta = all.map(m => ({
      id: m.id,
      filename: m.filename || "photo.jpg",
      created: m.created || nowISO(),
      folder: m.folder || "Unsorted",
      category: m.category || "Uncategorized",
      notes: m.notes || "",
      order: Number.isFinite(m.order) ? m.order : 0,
      anno: Array.isArray(m.anno) ? m.anno : []
    }));

    // Initialize order if missing
    if (meta.length && meta.every(x => !x.order)){
      // oldest first => 1..N
      meta.sort((a,b) => (a.created||"").localeCompare(b.created||""));
      meta.forEach((x,i) => x.order = i+1);
      await persistOrderAll();
    }
    sortByOrder();
    $("#count").textContent = String(meta.length);
  }

  function sortByOrder(){
    meta.sort((a,b) => (a.order ?? 0) - (b.order ?? 0));
  }

  async function persistMetaPatch(id, patch){
    const t = tx([STORE_META], "readwrite");
    const s = t.objectStore(STORE_META);
    const cur = await idbGet(s, id);
    if (!cur) { t.abort(); return; }
    await idbPut(s, {...cur, ...patch});
    await waitTxDone(t);

    const idx = meta.findIndex(x => x.id === id);
    if (idx >= 0) meta[idx] = {...meta[idx], ...patch};
  }

  async function persistOrderAll(){
    const t = tx([STORE_META], "readwrite");
    const s = t.objectStore(STORE_META);
    for (const m of meta){
      const cur = await idbGet(s, m.id);
      if (!cur) continue;
      await idbPut(s, {...cur, order: m.order});
    }
    await waitTxDone(t);
  }

  // =======================
  // Add photos
  // =======================
  async function addFiles(files){
    const defaultFolder = $("#folderSel").value;
    const defaultCat = $("#catSel").value;

    const maxOrder = meta.reduce((mx, m) => Math.max(mx, m.order || 0), 0);

    const t = tx([STORE_PHOTOS, STORE_META], "readwrite");
    const sP = t.objectStore(STORE_PHOTOS);
    const sM = t.objectStore(STORE_META);

    let added = 0;
    for (const f of files){
      if (!f.type.startsWith("image/")) continue;
      const id = uuid();
      await idbPut(sP, {id, blob: f, type: f.type || "image/jpeg"});

      const m = {
        id,
        filename: f.name || `photo_${added+1}.jpg`,
        created: nowISO(),
        folder: defaultFolder,
        category: defaultCat,
        notes: "",
        order: maxOrder + added + 1,
        anno: []
      };
      await idbPut(sM, m);
      meta.push(m);
      added++;
    }

    await waitTxDone(t);
    sortByOrder();
    toast(`Added ${added} photo(s).`);
    renderGrid();
  }

  // =======================
  // Delete (FIXED + reliable)
  // =======================
  async function deletePhoto(id){
    const t = tx([STORE_PHOTOS, STORE_META], "readwrite");
    await idbDel(t.objectStore(STORE_PHOTOS), id).catch(()=>{});
    await idbDel(t.objectStore(STORE_META), id).catch(()=>{});
    await waitTxDone(t);

    meta = meta.filter(x => x.id !== id);

    // re-number orders 1..N
    meta.forEach((m,i) => m.order = i+1);
    await persistOrderAll();

    $("#count").textContent = String(meta.length);
    renderGrid();

    // fix viewer index safely
    if ($("#overlay").classList.contains("show")){
      if (!meta.length){
        closeViewer();
      } else {
        viewerIndex = Math.min(viewerIndex, meta.length - 1);
        await openViewerByIndex(viewerIndex, true);
      }
    }
  }

  // =======================
  // Wipe
  // =======================
  async function wipeAll(){
    await new Promise((resolve) => {
      const req = indexedDB.deleteDatabase(DB_NAME);
      req.onsuccess = resolve;
      req.onerror = resolve;
      req.onblocked = resolve;
    });
    db = await openDB();
    meta = [];
    $("#count").textContent = "0";
    renderGrid();
    closeViewer();
  }

  // =======================
  // Thumbnails
  // =======================
  async function loadThumb(id, imgEl){
    try{
      const t = tx([STORE_PHOTOS], "readonly");
      const rec = await idbGet(t.objectStore(STORE_PHOTOS), id);
      if (!rec?.blob) return;
      const url = URL.createObjectURL(rec.blob);
      imgEl.src = url;
      imgEl.onload = () => URL.revokeObjectURL(url);
    } catch(e){
      console.error(e);
    }
  }

  function renderGrid(){
    const grid = $("#grid");
    grid.innerHTML = "";
    $("#empty").style.display = meta.length ? "none" : "";

    // ensure order -> numbering is correct
    sortByOrder();
    meta.forEach((m, idx) => m.order = idx + 1);

    // insert indicator elements
    const insertBadge = $("#insertBadge");

    meta.forEach((m, idx) => {
      const div = document.createElement("div");
      div.className = "thumb";
      div.dataset.id = m.id;
      div.dataset.index = String(idx);

      const img = document.createElement("img");
      img.alt = m.filename || "photo";
      div.appendChild(img);

      const num = document.createElement("div");
      num.className = "num";
      num.textContent = String(idx + 1);
      div.appendChild(num);

      const tags = document.createElement("div");
      tags.className = "tagbar";
      tags.innerHTML = `<span class="chip">${esc(m.folder)}</span><span class="chip">${esc(m.category)}</span>`;
      div.appendChild(tags);

      // insert line for this thumb (for before/after visuals)
      const line = document.createElement("div");
      line.className = "insertLine";
      div.appendChild(line);

      div.addEventListener("click", () => openViewerByIndex(idx, true));

      // custom mobile-friendly drag reorder via pointer events
      div.addEventListener("pointerdown", (e) => {
        // left click / touch only
        if (e.button !== undefined && e.button !== 0) return;
        startDrag(e, div, idx);
      });

      grid.appendChild(div);
      loadThumb(m.id, img);
    });

    // update badge hiding
    if (!dragging){
      insertBadge.style.display = "none";
    }
  }

  function startDrag(e, el, index){
    // don‚Äôt start drag if viewer is open
    if ($("#overlay").classList.contains("show")) return;

    e.preventDefault();
    el.setPointerCapture(e.pointerId);

    const rect = el.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    const ghost = el.cloneNode(true);
    ghost.style.position = "fixed";
    ghost.style.left = (e.clientX - offsetX) + "px";
    ghost.style.top = (e.clientY - offsetY) + "px";
    ghost.style.width = rect.width + "px";
    ghost.style.height = rect.height + "px";
    ghost.style.opacity = "0.92";
    ghost.style.zIndex = "9999";
    ghost.style.pointerEvents = "none";
    ghost.style.boxShadow = "0 18px 40px rgba(0,0,0,.55)";
    ghost.style.transform = "scale(1.02)";
    document.body.appendChild(ghost);

    dragging = { id: el.dataset.id, startIndex: index, ghost, offsetX, offsetY };

    // show badge
    const badge = $("#insertBadge");
    badge.style.display = "block";
    badge.textContent = "Dragging‚Ä¶";

    const move = (ev) => onDragMove(ev);
    const up = (ev) => onDragEnd(ev, move, up);

    window.addEventListener("pointermove", move, {passive:false});
    window.addEventListener("pointerup", up, {passive:false});
  }

  function clearInsertIndicators(){
    $("#grid").querySelectorAll(".insertLine").forEach(l => l.style.display = "none");
  }

  function onDragMove(e){
    if (!dragging) return;
    e.preventDefault();

    // move ghost
    dragging.ghost.style.left = (e.clientX - dragging.offsetX) + "px";
    dragging.ghost.style.top  = (e.clientY - dragging.offsetY) + "px";

    // find hovered thumb
    const thumbs = Array.from($("#grid").querySelectorAll(".thumb"));
    let best = null;

    for (const t of thumbs){
      const r = t.getBoundingClientRect();
      // small padding to make it easier
      if (e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom){
        best = { el: t, rect: r, index: Number(t.dataset.index) };
        break;
      }
    }

    clearInsertIndicators();
    insertTarget = null;

    const badge = $("#insertBadge");
    if (!best){
      badge.textContent = "Move to a position‚Ä¶";
      return;
    }

    const midX = (best.rect.left + best.rect.right) / 2;
    const side = (e.clientX < midX) ? "before" : "after";

    // set insert line inside this thumb
    const line = best.el.querySelector(".insertLine");
    line.style.display = "block";
    line.style.left = (side === "before" ? "8px" : "calc(100% - 8px)");

    insertTarget = { index: best.index, side };

    // BEFORE/AFTER label with numbering
    const placeNum = best.index + 1;
    badge.textContent = side === "before"
      ? `Place BEFORE #${placeNum} (in front)`
      : `Place AFTER #${placeNum} (behind)`;
  }

  async function onDragEnd(e, moveHandler, upHandler){
    if (!dragging) return;
    e.preventDefault();

    window.removeEventListener("pointermove", moveHandler);
    window.removeEventListener("pointerup", upHandler);

    clearInsertIndicators();
    $("#insertBadge").style.display = "none";

    dragging.ghost.remove();

    const from = dragging.startIndex;
    let to = from;

    if (insertTarget){
      to = insertTarget.index + (insertTarget.side === "after" ? 1 : 0);
      // if dragging forward in list, account for removal shift
      if (to > from) to -= 1;
      to = Math.max(0, Math.min(to, meta.length - 1));
    }

    const draggedId = dragging.id;
    dragging = null;
    insertTarget = null;

    if (to === from) return;

    // reorder array
    const item = meta.splice(from, 1)[0];
    meta.splice(to, 0, item);

    // rewrite order 1..N and persist
    meta.forEach((m,i) => m.order = i+1);
    await persistOrderAll();

    toast(`Moved to #${to+1}`);
    renderGrid();
  }

  // =======================
  // Export CSV
  // =======================
  function downloadText(filename, text, type="text/plain"){
    const blob = new Blob([text], {type});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function csv(s){
    const t = (s ?? "").toString().replaceAll('"','""');
    return `"${t}"`;
  }
  function dateStamp(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}${m}${day}`;
  }
  function exportCSV(){
    sortByOrder();
    const header = ["order","filename","created","folder","category","notes","annoCount"].join(",");
    const lines = meta.map(m => [
      String(m.order || 0),
      csv(m.filename),
      m.created,
      csv(m.folder),
      csv(m.category),
      csv(m.notes),
      String((m.anno||[]).length)
    ].join(","));
    downloadText(`mitchell_photos_${dateStamp()}.csv`, [header, ...lines].join("\n"), "text/csv");
    toast("CSV exported.");
  }

  // =======================
  // Viewer open/close + nav
  // =======================
  async function openViewerByIndex(i, refreshUI=false){
    sortByOrder();
    viewerIndex = Math.max(0, Math.min(i, meta.length - 1));
    const m = meta[viewerIndex];
    if (!m) return;

    $("#overlay").classList.add("show");
    $("#overlay").setAttribute("aria-hidden","false");
    $("#posPill").textContent = `${viewerIndex+1} / ${meta.length}`;
    $("#fileName").textContent = `#${viewerIndex+1} ‚Ä¢ ${m.filename || "‚Äî"}`;
    $("#vFolder").value = m.folder || "Unsorted";
    $("#vCat").value = m.category || "Uncategorized";
    $("#vNotes").value = m.notes || "";

    // load image into canvas
    await loadImageToCanvas(m.id);

    // load annotations
    anno = Array.isArray(m.anno) ? structuredClone(m.anno) : [];
    undoStack = [];
    resetView();
    redraw();

    setArrowState();

    if (!refreshUI) return;
  }

  function closeViewer(){
    $("#overlay").classList.remove("show");
    $("#overlay").setAttribute("aria-hidden","true");
    imgBitmap = null;
    anno = [];
    undoStack = [];
    viewerIndex = -1;
  }

  function setArrowState(){
    const canPrev = viewerIndex > 0;
    const canNext = viewerIndex < meta.length - 1;
    $("#prevBtn").disabled = !canPrev;
    $("#nextBtn").disabled = !canNext;
    $("#bigPrev").setAttribute("aria-disabled", canPrev ? "false" : "true");
    $("#bigNext").setAttribute("aria-disabled", canNext ? "false" : "true");
  }

  function step(dir){
    const next = viewerIndex + dir;
    if (next < 0 || next >= meta.length) return;
    openViewerByIndex(next, true);
  }

  // =======================
  // Canvas / Markup drawing
  // =======================
  function resizeCanvasToContainer(){
    const host = $("#vLeft").getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(host.width * dpr);
    canvas.height = Math.floor(host.height * dpr);
    canvas.style.width = host.width + "px";
    canvas.style.height = host.height + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  async function loadImageToCanvas(photoId){
    // fetch blob
    const t = tx([STORE_PHOTOS], "readonly");
    const rec = await idbGet(t.objectStore(STORE_PHOTOS), photoId);
    if (!rec?.blob){
      imgBitmap = null;
      return;
    }
    // decode
    imgBitmap = await createImageBitmap(rec.blob);
    resizeCanvasToContainer();
  }

  function resetView(){
    view.tx = 0; view.ty = 0; view.scale = 1;

    if (!imgBitmap) return;

    // fit image inside canvas (CSS pixels)
    const cw = canvas.clientWidth;
    const ch = canvas.clientHeight;
    const iw = imgBitmap.width;
    const ih = imgBitmap.height;

    const s = Math.min(cw / iw, ch / ih);
    view.scale = s;
    // center
    const dw = iw * s;
    const dh = ih * s;
    view.tx = (cw - dw) / 2;
    view.ty = (ch - dh) / 2;
  }

  function screenToWorld(x,y){
    // invert view transform
    const wx = (x - view.tx) / view.scale;
    const wy = (y - view.ty) / view.scale;
    return {x: wx, y: wy};
  }

  function snapPoint(p){
    if (!snapAngles) return p;
    // snap relative to start point (for line-like tools)
    const dx = p.x - start.x;
    const dy = p.y - start.y;
    const ang = Math.atan2(dy, dx);
    const step = Math.PI / 12; // 15 degrees
    const snapped = Math.round(ang / step) * step;
    const len = Math.hypot(dx,dy);
    return { x: start.x + Math.cos(snapped) * len, y: start.y + Math.sin(snapped) * len };
  }

  function redraw(){
    resizeCanvasToContainer();

    const cw = canvas.clientWidth;
    const ch = canvas.clientHeight;

    // clear
    ctx.clearRect(0,0,cw,ch);

    // draw image
    if (imgBitmap){
      ctx.save();
      ctx.translate(view.tx, view.ty);
      ctx.scale(view.scale, view.scale);
      ctx.drawImage(imgBitmap, 0, 0);
      ctx.restore();
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fillRect(0,0,cw,ch);
    }

    // draw existing shapes
    drawShapes(anno);

    // draw temp shape
    if (temp) drawShapes([temp], true);
  }

  function drawShapes(list, isTemp=false){
    if (!imgBitmap) return;
    for (const s of list){
      // outer stroke (dark) + inner (green)
      drawShapeStroke(s, STROKE2, WIDTH + 2, isTemp);
      drawShapeStroke(s, STROKE,  WIDTH,     isTemp);
    }
  }

  function drawShapeStroke(s, color, width, isTemp){
    const cw = canvas.clientWidth;
    const ch = canvas.clientHeight;

    ctx.save();
    // world->screen transform
    ctx.translate(view.tx, view.ty);
    ctx.scale(view.scale, view.scale);

    ctx.strokeStyle = color;
    ctx.lineWidth = width / view.scale;
    ctx.fillStyle = "transparent";
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.setLineDash(isTemp ? [8 / view.scale, 6 / view.scale] : []);

    const drawLabel = (txt, x, y) => {
      ctx.save();
      ctx.setLineDash([]);
      ctx.font = `${14 / view.scale}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial`;
      ctx.fillStyle = color;
      ctx.strokeStyle = "rgba(0,0,0,0.6)";
      ctx.lineWidth = 4 / view.scale;
      ctx.strokeText(txt, x, y);
      ctx.fillText(txt, x, y);
      ctx.restore();
    };

    if (s.type === "line"){
      ctx.beginPath();
      ctx.moveTo(s.x1, s.y1);
      ctx.lineTo(s.x2, s.y2);
      ctx.stroke();
    }
    else if (s.type === "rect"){
      const x = Math.min(s.x1, s.x2);
      const y = Math.min(s.y1, s.y2);
      const w = Math.abs(s.x2 - s.x1);
      const h = Math.abs(s.y2 - s.y1);
      ctx.strokeRect(x,y,w,h);
    }
    else if (s.type === "circle"){
      const cx = (s.x1 + s.x2) / 2;
      const cy = (s.y1 + s.y2) / 2;
      const rx = Math.abs(s.x2 - s.x1) / 2;
      const ry = Math.abs(s.y2 - s.y1) / 2;
      ctx.beginPath();
      // ellipse
      if (ctx.ellipse) ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      else {
        // fallback
        ctx.save();
        ctx.translate(cx,cy);
        ctx.scale(rx || 1, ry || 1);
        ctx.arc(0,0,1,0,Math.PI*2);
        ctx.restore();
      }
      ctx.stroke();
    }
    else if (s.type === "arrow"){
      // main line
      ctx.beginPath();
      ctx.moveTo(s.x1, s.y1);
      ctx.lineTo(s.x2, s.y2);
      ctx.stroke();
      // arrow head
      const dx = s.x2 - s.x1;
      const dy = s.y2 - s.y1;
      const ang = Math.atan2(dy, dx);
      const headLen = 18 / view.scale;
      const a1 = ang - Math.PI / 8;
      const a2 = ang + Math.PI / 8;
      ctx.beginPath();
      ctx.moveTo(s.x2, s.y2);
      ctx.lineTo(s.x2 - Math.cos(a1) * headLen, s.y2 - Math.sin(a1) * headLen);
      ctx.moveTo(s.x2, s.y2);
      ctx.lineTo(s.x2 - Math.cos(a2) * headLen, s.y2 - Math.sin(a2) * headLen);
      ctx.stroke();
    }
    else if (s.type === "angle"){
      // angle: p1->v and v->p2
      ctx.beginPath();
      ctx.moveTo(s.vx, s.vy);
      ctx.lineTo(s.x1, s.y1);
      ctx.moveTo(s.vx, s.vy);
      ctx.lineTo(s.x2, s.y2);
      ctx.stroke();

      // compute degrees
      const a = {x: s.x1 - s.vx, y: s.y1 - s.vy};
      const b = {x: s.x2 - s.vx, y: s.y2 - s.vy};
      const dot = a.x*b.x + a.y*b.y;
      const la = Math.hypot(a.x,a.y);
      const lb = Math.hypot(b.x,b.y);
      const deg = (la && lb) ? Math.acos(Math.max(-1, Math.min(1, dot/(la*lb)))) * 180/Math.PI : 0;
      drawLabel(`${deg.toFixed(1)}¬∞`, s.vx + 8, s.vy - 8);
    }
    else if (s.type === "ruler"){
      // measure line + length (pixels)
      ctx.beginPath();
      ctx.moveTo(s.x1, s.y1);
      ctx.lineTo(s.x2, s.y2);
      ctx.stroke();
      const len = Math.hypot(s.x2 - s.x1, s.y2 - s.y1);
      const mx = (s.x1 + s.x2) / 2;
      const my = (s.y1 + s.y2) / 2;
      drawLabel(`${len.toFixed(0)} px`, mx + 8, my - 8);
    }

    ctx.restore();
  }

  function pushUndo(){
    undoStack.push(structuredClone(anno));
    if (undoStack.length > 50) undoStack.shift();
  }

  function setTool(next){
    tool = next;
    document.querySelectorAll(".toolbtn").forEach(b => {
      b.classList.toggle("active", b.dataset.tool === tool);
    });
  }

  function pointerPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  // =======================
  // UI wiring
  // =======================
  async function init(){
    db = await openDB();
    buildSelects();
    await loadMeta();
    renderGrid();
    wireUI();
  }

  function wireUI(){
    // Add files
    $("#fileInput").addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      e.target.value = "";
      if (files.length) await addFiles(files);
    });
    $("#camInput").addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      e.target.value = "";
      if (files.length) await addFiles(files);
    });

    // Drop zone
    const dz = $("#dropZone");
    ["dragenter","dragover"].forEach(ev => dz.addEventListener(ev, (e) => {
      e.preventDefault(); e.stopPropagation();
      dz.classList.add("drag");
    }));
    ["dragleave","drop"].forEach(ev => dz.addEventListener(ev, (e) => {
      e.preventDefault(); e.stopPropagation();
      dz.classList.remove("drag");
    }));
    dz.addEventListener("drop", async (e) => {
      const files = Array.from(e.dataTransfer.files || []).filter(f => f.type.startsWith("image/"));
      if (!files.length) return toast("No image files detected.");
      await addFiles(files);
    });

    // Export / wipe
    $("#exportCsv").addEventListener("click", exportCSV);
    $("#wipeAll").addEventListener("click", async () => {
      if (!confirm("Wipe all photos on THIS device/browser?")) return;
      await wipeAll();
      toast("Wiped.");
    });

    // Snap toggle
    $("#snapToggle").addEventListener("click", () => {
      snapAngles = !snapAngles;
      $("#snapToggle").textContent = `Snap: ${snapAngles ? "ON" : "OFF"}`;
      $("#snapToggle").classList.toggle("ok", snapAngles);
    });

    // Viewer nav + close
    $("#closeBtn").addEventListener("click", closeViewer);
    $("#overlay").addEventListener("click", (e) => { if (e.target.id === "overlay") closeViewer(); });

    $("#prevBtn").addEventListener("click", () => step(-1));
    $("#nextBtn").addEventListener("click", () => step(+1));
    $("#bigPrev").addEventListener("click", () => step(-1));
    $("#bigNext").addEventListener("click", () => step(+1));

    // Keyboard
    document.addEventListener("keydown", (e) => {
      if (!$("#overlay").classList.contains("show")) return;
      if (e.key === "Escape") closeViewer();
      if (e.key === "ArrowLeft") step(-1);
      if (e.key === "ArrowRight") step(+1);
    });

    // Save / delete
    $("#saveBtn").addEventListener("click", async () => {
      if (viewerIndex < 0) return;
      const m = meta[viewerIndex];
      if (!m) return;

      const patch = {
        folder: $("#vFolder").value,
        category: $("#vCat").value,
        notes: $("#vNotes").value || "",
        anno: structuredClone(anno)
      };
      await persistMetaPatch(m.id, patch);
      toast("Saved.");
      renderGrid();
      // keep viewer labels in sync
      $("#fileName").textContent = `#${viewerIndex+1} ‚Ä¢ ${m.filename || "‚Äî"}`;
    });

    $("#delBtn").addEventListener("click", async () => {
      if (viewerIndex < 0) return;
      const m = meta[viewerIndex];
      if (!m) return;
      if (!confirm(`Delete photo #${viewerIndex+1}?`)) return;
      await deletePhoto(m.id);
      toast("Deleted.");
    });

    // Tools
    setTool("arrow");
    $("#toolbar").addEventListener("click", (e) => {
      const btn = e.target.closest(".toolbtn");
      if (!btn) return;
      setTool(btn.dataset.tool);
    });

    // Undo/clear/reset view
    $("#undoBtn").addEventListener("click", () => {
      if (!undoStack.length) return;
      anno = undoStack.pop();
      redraw();
    });
    $("#clearBtn").addEventListener("click", () => {
      if (!anno.length) return;
      if (!confirm("Clear all markup on this photo?")) return;
      pushUndo();
      anno = [];
      redraw();
    });
    $("#resetViewBtn").addEventListener("click", () => {
      resetView();
      redraw();
    });

    // Canvas interaction
    canvas.addEventListener("pointerdown", (e) => {
      if (!imgBitmap) return;
      canvas.setPointerCapture(e.pointerId);
      isDown = true;

      const p = pointerPos(e);
      const w = screenToWorld(p.x, p.y);
      start = w;
      curr = w;
      temp = null;

      // Shift snap on desktop
      if (e.shiftKey) snapAngles = true;

      if (tool === "pan"){
        // just pan using delta in screen coords
        start._sx = p.x;
        start._sy = p.y;
        start._tx = view.tx;
        start._ty = view.ty;
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!isDown || !imgBitmap) return;
      const p = pointerPos(e);

      if (tool === "pan"){
        // pan in screen space
        const dx = p.x - (start._sx || 0);
        const dy = p.y - (start._sy || 0);
        view.tx = (start._tx || 0) + dx;
        view.ty = (start._ty || 0) + dy;
        redraw();
        return;
      }

      const w = screenToWorld(p.x, p.y);
      curr = w;

      // line-like snapping
      let end = w;
      if (snapAngles || e.shiftKey){
        end = snapPoint(w);
      }

      if (tool === "rect") temp = {type:"rect", x1:start.x, y1:start.y, x2:end.x, y2:end.y};
      else if (tool === "circle") temp = {type:"circle", x1:start.x, y1:start.y, x2:end.x, y2:end.y};
      else if (tool === "line") temp = {type:"line", x1:start.x, y1:start.y, x2:end.x, y2:end.y};
      else if (tool === "arrow") temp = {type:"arrow", x1:start.x, y1:start.y, x2:end.x, y2:end.y};
      else if (tool === "ruler") temp = {type:"ruler", x1:start.x, y1:start.y, x2:end.x, y2:end.y};
      else if (tool === "angle"){
        // angle uses 3 points: first click sets vertex, drag defines p1 and p2 using start as vertex
        // Here: start is vertex; current drag defines p2; we keep p1 fixed as a short reference direction
        const ref = { x: start.x + 120, y: start.y }; // default reference line
        const snappedEnd = (snapAngles || e.shiftKey) ? snapPoint(w) : w;
        temp = {type:"angle", vx:start.x, vy:start.y, x1:ref.x, y1:ref.y, x2:snappedEnd.x, y2:snappedEnd.y};
      }

      redraw();
    });

    canvas.addEventListener("pointerup", (e) => {
      if (!isDown) return;
      isDown = false;

      if (tool === "pan"){
        // nothing to commit
        return;
      }

      if (temp){
        pushUndo();
        anno.push(temp);
        temp = null;
        redraw();
      }
    });

    // Handle resize
    window.addEventListener("resize", () => {
      if (!$("#overlay").classList.contains("show")) return;
      resizeCanvasToContainer();
      redraw();
    });
  }

  // =======================
  // Boot
  // =======================
  init().catch(err => {
    console.error(err);
    toast("Failed to load.");
  });
})();
</script>
</body>
</html>
