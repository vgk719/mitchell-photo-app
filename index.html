<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Mitchell v11</title>
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    /* RESET */
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
    body { margin: 0; background: #121212; color: #fff; font-family: -apple-system, system-ui, sans-serif; height: 100vh; overflow: hidden; }

    /* LAYOUT */
    #app { display: flex; flex-direction: column; height: 100%; }
    
    header {
      padding: 15px; background: #1e1e1e; border-bottom: 1px solid #333;
      display: flex; justify-content: space-between; align-items: center;
      padding-top: max(15px, env(safe-area-inset-top));
    }
    h1 { margin: 0; font-size: 18px; font-weight: 800; }
    
    /* SCROLLABLE MAIN AREA */
    main { flex: 1; overflow-y: auto; padding: 15px; padding-bottom: 100px; }

    /* BIG BUTTONS */
    .btn {
      background: #333; border: none; color: white; padding: 12px 20px;
      border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer;
    }
    .btn:active { opacity: 0.7; }
    .btn.primary { background: #3b82f6; } /* Blue */
    .btn.danger { background: #ef4444; }  /* Red */
    .btn.success { background: #22c55e; color: #000; } /* Green */
    
    /* INPUTS */
    input[type=text] {
      width: 100%; padding: 15px; border-radius: 12px; border: 1px solid #444;
      background: #222; color: white; font-size: 16px; margin-bottom: 20px;
    }

    /* MASSIVE THUMBNAILS (2 per row) */
    .grid {
      display: grid; 
      grid-template-columns: 1fr 1fr; /* 2 PER ROW - HUGE */
      gap: 15px; margin-top: 20px;
    }
    .card {
      aspect-ratio: 1; background: #000; border-radius: 12px; overflow: hidden;
      position: relative; border: 2px solid #333;
    }
    .card img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
    .card-num {
      position: absolute; top: 8px; left: 8px; background: rgba(0,0,0,0.7);
      color: white; padding: 4px 10px; border-radius: 20px; font-weight: bold;
    }

    /* DRAG HANDLE (Yellow) */
    .handle {
      position: absolute; top: 0; right: 0; width: 60px; height: 60px;
      background: rgba(255, 200, 0, 0.2); /* Slight yellow tint */
      display: flex; align-items: center; justify-content: center;
      font-size: 30px; z-index: 10;
    }

    /* CAMERA OVERLAY */
    #camUI {
      position: fixed; inset: 0; background: #000; z-index: 900;
      display: none; flex-direction: column;
    }
    #camUI.show { display: flex; }
    
    #camView { flex: 1; position: relative; background: #111; }
    video { width: 100%; height: 100%; object-fit: cover; }
    
    /* FIXED SHUTTER BUTTON */
    #shutter {
      width: 80px; height: 80px; border-radius: 50%; background: white;
      border: 4px solid #ccc; position: absolute; bottom: 30px; left: 50%;
      transform: translateX(-50%); z-index: 910;
    }
    #shutter:active { transform: translateX(-50%) scale(0.9); background: #eee; }

    /* EDITOR OVERLAY */
    #editUI {
      position: fixed; inset: 0; background: #111; z-index: 800;
      display: none; flex-direction: column;
    }
    #editUI.show { display: flex; }
    
    #canvasWrap { flex: 1; position: relative; overflow: hidden; touch-action: none; }
    canvas { display: block; width: 100%; height: 100%; }

    .toolbar {
      padding: 20px; background: #222; border-top: 1px solid #444;
      padding-bottom: max(20px, env(safe-area-inset-bottom));
      display: flex; gap: 10px; overflow-x: auto;
    }
    .tool {
      flex: 0 0 50px; height: 50px; background: #333; border-radius: 10px;
      display: flex; align-items: center; justify-content: center; font-size: 20px;
    }
    .tool.active { background: #3b82f6; color: white; }

    /* GHOST (Dragging) */
    .ghost {
      position: fixed; width: 100px; height: 100px; border: 2px solid #22c55e;
      background: rgba(0,0,0,0.8); z-index: 9999; pointer-events: none;
      border-radius: 12px;
    }
    .drop-line {
      position: absolute; top: 0; bottom: 0; width: 5px; background: #22c55e;
      display: none; z-index: 5; box-shadow: 0 0 10px #22c55e;
    }
  </style>
</head>
<body>

<div id="app">
  <header>
    <div>
      <h1 style="color: hotpink;">Mitchell v11</h1>
      <small style="color:#888" id="status">Ready</small>
    </div>
    <div class="btn success" style="padding: 5px 12px; font-size:12px;" id="count">0</div>
  </header>

  <main>
    <input type="text" id="jobName" placeholder="Job Name...">

    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
      <button class="btn primary" onclick="ui.setFolder('Walk Around')">Walk</button>
      <button class="btn" onclick="ui.setFolder('UPD')">UPD</button>
      <button class="btn" onclick="ui.setFolder('Teardown')">Tear</button>
    </div>

    <h2 id="folderHeader">Walk Around</h2>
    
    <div id="grid" class="grid"></div>
  </main>

  <div style="padding: 20px; background: #1e1e1e; border-top: 1px solid #333; display: flex; gap: 10px; padding-bottom: max(20px, env(safe-area-inset-bottom));">
    <button class="btn primary" style="flex:1" onclick="cam.open()">üì∏ PHOTO</button>
    <button class="btn success" style="flex:1" onclick="document.getElementById('upl').click()">‚¨ÜÔ∏è UPLOAD</button>
    <input type="file" id="upl" hidden multiple accept="image/*" onchange="ui.handleUpload(this)">
  </div>
</div>

<div id="camUI">
  <div id="camView">
    <video id="vid" autoplay playsinline muted></video>
    <div id="shutter" onclick="cam.snap()"></div>
    <button class="btn" style="position: absolute; top: 20px; right: 20px; z-index:920;" onclick="cam.close()">Done</button>
  </div>
</div>

<div id="editUI">
  <div id="canvasWrap">
    <canvas id="cvs"></canvas>
  </div>
  <div class="toolbar">
    <div class="tool active" onclick="editor.setTool('arrow', this)">‚û§</div>
    <div class="tool" onclick="editor.setTool('circle', this)">‚óØ</div>
    <div class="tool" onclick="editor.setTool('rect', this)">‚ñ¢</div>
    <div class="tool" onclick="editor.setTool('text', this)">T</div>
    <div style="width: 20px;"></div>
    <button class="btn" onclick="editor.undo()">Undo</button>
    <button class="btn danger" onclick="editor.del()">Delete</button>
    <button class="btn primary" onclick="editor.close()">Save</button>
  </div>
</div>

<script>
// --- DATA STORE (IndexedDB) ---
const dbName = "Mitchell_v11_Pro";
let db = null;
let currentFolder = "Walk Around";
let metaData = [];

function initDB() {
  const req = indexedDB.open(dbName, 1);
  req.onupgradeneeded = e => {
    const d = e.target.result;
    d.createObjectStore("files", { keyPath: "id" });
    d.createObjectStore("meta", { keyPath: "id" });
  };
  req.onsuccess = e => {
    db = e.target.result;
    loadData();
  };
}

function loadData() {
  if (!db) return;
  const tx = db.transaction("meta", "readonly");
  const store = tx.objectStore("meta");
  const req = store.getAll();
  req.onsuccess = () => {
    metaData = req.result || [];
    ui.render();
  };
}

function saveData(id, blob, folder) {
  const tx = db.transaction(["files", "meta"], "readwrite");
  const meta = {
    id: id,
    folder: folder,
    order: Date.now(), // Simple ordering
    anno: []
  };
  tx.objectStore("files").put({ id: id, blob: blob });
  tx.objectStore("meta").put(meta);
  tx.oncomplete = () => loadData();
}

// --- UI LOGIC ---
const ui = {
  setFolder: (name) => {
    currentFolder = name;
    document.getElementById("folderHeader").textContent = name;
    ui.render();
  },
  
  render: () => {
    const list = metaData.filter(m => m.folder === currentFolder)
                         .sort((a,b) => a.order - b.order);
    
    document.getElementById("count").textContent = metaData.length;
    const grid = document.getElementById("grid");
    grid.innerHTML = "";

    list.forEach((m, i) => {
      const el = document.createElement("div");
      el.className = "card";
      // Massive Thumbnails (2 per row)
      el.innerHTML = `
        <img id="img-${m.id}" />
        <div class="card-num">${i+1}</div>
        <div class="handle" ontouchstart="drag.start(event, '${m.id}')">‚ãÆ</div>
        <div class="drop-line"></div>
      `;
      // Load Image
      const tx = db.transaction("files", "readonly");
      tx.objectStore("files").get(m.id).onsuccess = (e) => {
        if (e.target.result) {
          document.getElementById("img-"+m.id).src = URL.createObjectURL(e.target.result.blob);
        }
      };
      // Edit Click
      el.onclick = (e) => {
        if(!e.target.classList.contains("handle")) editor.open(m.id);
      }
      grid.appendChild(el);
    });
  },

  handleUpload: (input) => {
    [...input.files].forEach(file => {
      saveData(crypto.randomUUID(), file, currentFolder);
    });
  }
};

// --- CAMERA (SIMPLE) ---
const cam = {
  stream: null,
  open: async () => {
    document.getElementById("camUI").classList.add("show");
    try {
      // Audio false prevents "recording" mode on some browsers
      cam.stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "environment" }, 
        audio: false 
      });
      document.getElementById("vid").srcObject = cam.stream;
    } catch(e) {
      alert("Camera Error: " + e.message);
    }
  },
  snap: () => {
    const vid = document.getElementById("vid");
    const cvs = document.createElement("canvas");
    cvs.width = vid.videoWidth;
    cvs.height = vid.videoHeight;
    cvs.getContext("2d").drawImage(vid, 0, 0);
    
    cvs.toBlob(blob => {
      saveData(crypto.randomUUID(), blob, currentFolder);
      // Visual Flash
      vid.style.opacity = 0;
      setTimeout(() => vid.style.opacity = 1, 100);
    }, "image/jpeg", 0.8);
  },
  close: () => {
    document.getElementById("camUI").classList.remove("show");
    if(cam.stream) cam.stream.getTracks().forEach(t => t.stop());
  }
};

// --- EDITOR (TOUCH FRIENDLY) ---
const editor = {
  id: null,
  img: null,
  anno: [],
  tool: 'arrow',
  
  open: async (id) => {
    editor.id = id;
    const m = metaData.find(x => x.id === id);
    editor.anno = m.anno || [];
    
    // Get Image
    const tx = db.transaction("files", "readonly");
    tx.objectStore("files").get(id).onsuccess = (e) => {
      const blob = e.target.result.blob;
      editor.img = new Image();
      editor.img.onload = () => {
        document.getElementById("editUI").classList.add("show");
        editor.resize();
        editor.draw();
      };
      editor.img.src = URL.createObjectURL(blob);
    };
  },
  
  resize: () => {
    const wrap = document.getElementById("canvasWrap");
    const cvs = document.getElementById("cvs");
    cvs.width = wrap.clientWidth;
    cvs.height = wrap.clientHeight;
  },
  
  draw: () => {
    const cvs = document.getElementById("cvs");
    const ctx = cvs.getContext("2d");
    ctx.clearRect(0,0,cvs.width,cvs.height);
    
    // Draw Image Scaled
    const sc = Math.min(cvs.width/editor.img.width, cvs.height/editor.img.height);
    const x = (cvs.width - editor.img.width*sc)/2;
    const y = (cvs.height - editor.img.height*sc)/2;
    ctx.drawImage(editor.img, x, y, editor.img.width*sc, editor.img.height*sc);
    
    // Draw Anno
    editor.anno.forEach(a => {
      const sx = a.x1 * cvs.width;
      const sy = a.y1 * cvs.height;
      const ex = a.x2 * cvs.width;
      const ey = a.y2 * cvs.height;
      
      ctx.strokeStyle = "#22c55e";
      ctx.lineWidth = 4;
      ctx.beginPath();
      
      if(a.type === 'rect') ctx.strokeRect(sx, sy, ex-sx, ey-sy);
      if(a.type === 'circle') {
        const r = Math.hypot(ex-sx, ey-sy);
        ctx.beginPath(); ctx.arc(sx, sy, r, 0, 7); ctx.stroke();
      }
      if(a.type === 'arrow') {
        ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
        ctx.beginPath(); ctx.arc(ex, ey, 5, 0, 7); ctx.fillStyle="#22c55e"; ctx.fill();
      }
    });
  },
  
  setTool: (t, el) => {
    editor.tool = t;
    document.querySelectorAll(".tool").forEach(x => x.classList.remove("active"));
    el.classList.add("active");
  },
  undo: () => { editor.anno.pop(); editor.draw(); },
  del: () => {
    if(confirm("Delete?")) {
      const tx = db.transaction(["files","meta"], "readwrite");
      tx.objectStore("files").delete(editor.id);
      tx.objectStore("meta").delete(editor.id);
      tx.oncomplete = () => {
        editor.close();
        loadData();
      };
    }
  },
  close: () => {
    // Save Anno
    const tx = db.transaction("meta", "readwrite");
    const m = metaData.find(x => x.id === editor.id);
    m.anno = editor.anno;
    tx.objectStore("meta").put(m);
    tx.oncomplete = () => {
      document.getElementById("editUI").classList.remove("show");
      loadData();
    }
  }
};

// --- DRAWING LOGIC (TOUCH) ---
const cvs = document.getElementById("cvs");
let isDrawing = false;
let startX=0, startY=0;

const getPos = (e) => {
  const r = cvs.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  return { x: t.clientX - r.left, y: t.clientY - r.top };
}

cvs.addEventListener("touchstart", e => {
  e.preventDefault();
  isDrawing = true;
  const p = getPos(e);
  startX = p.x; startY = p.y;
}, {passive:false});

cvs.addEventListener("touchmove", e => {
  if(!isDrawing) return;
  e.preventDefault();
  editor.draw();
  // Preview
  const ctx = cvs.getContext("2d");
  const p = getPos(e);
  ctx.strokeStyle = "white"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(p.x, p.y); ctx.stroke();
}, {passive:false});

cvs.addEventListener("touchend", e => {
  if(!isDrawing) return;
  isDrawing = false;
  const p = getPos(e.changedTouches ? e.changedTouches[0] : e);
  
  editor.anno.push({
    type: editor.tool,
    x1: startX / cvs.width,
    y1: startY / cvs.height,
    x2: p.x / cvs.width,
    y2: p.y / cvs.height
  });
  editor.draw();
});

// --- DRAG LOGIC ---
const drag = {
  id: null,
  ghost: null,
  start: (e, id) => {
    e.preventDefault();
    drag.id = id;
    
    // Create Ghost
    drag.ghost = document.createElement("div");
    drag.ghost.className = "ghost";
    document.body.appendChild(drag.ghost);
    
    // Attach move listener
    document.addEventListener("touchmove", drag.move, {passive:false});
    document.addEventListener("touchend", drag.end);
  },
  move: (e) => {
    e.preventDefault();
    const t = e.touches[0];
    drag.ghost.style.left = t.clientX + "px";
    drag.ghost.style.top = t.clientY + "px";
    
    // Detect Drop Target
    const el = document.elementFromPoint(t.clientX, t.clientY);
    const card = el ? el.closest(".card") : null;
    document.querySelectorAll(".drop-line").forEach(l => l.style.display="none");
    if(card) {
      card.querySelector(".drop-line").style.display = "block";
    }
  },
  end: (e) => {
    document.removeEventListener("touchmove", drag.move);
    document.removeEventListener("touchend", drag.end);
    if(drag.ghost) drag.ghost.remove();
    
    const t = e.changedTouches[0];
    const el = document.elementFromPoint(t.clientX, t.clientY);
    const card = el ? el.closest(".card") : null;
    
    if(card) {
      // Reorder Logic (Simple Swap for robustness)
      const tx = db.transaction("meta", "readwrite");
      const s = tx.objectStore("meta");
      const movedItem = metaData.find(x => x.id === drag.id);
      // Simply push to end for safety in this version, or alert
      movedItem.order = Date.now(); // Moves to bottom
      s.put(movedItem);
      tx.oncomplete = () => loadData();
    }
  }
};

// Start
initDB();

</script>
</body>
</html>
