<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
  <title>Mitchell Teardown Photos</title>

  <meta name="theme-color" content="#070b16">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    :root{
      --bg:#070b16;
      --panel: rgba(18,28,55,.78);
      --panel2: rgba(12,18,38,.92);
      --border: rgba(255,255,255,.12);
      --text:#eef2ff;
      --muted:#a7b1d8;
      --primary:#3b82f6;
      --danger:#ef4444;
      --ok:#22c55e;
      --radius:16px;
      --shadow: 0 18px 44px rgba(0,0,0,.45);
      --safe-b: env(safe-area-inset-bottom, 0px);
      --safe-t: env(safe-area-inset-top, 0px);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 18% 10%, #1a2a66 0%, rgba(26,42,102,0) 55%),
        radial-gradient(900px 700px at 82% 0%, #173a7a 0%, rgba(23,58,122,0) 60%),
        var(--bg);
      overflow:hidden;
      padding-top: var(--safe-t);
    }

    header{
      padding: 14px 14px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
    }
    h1{ margin:0; font-size:16px; font-weight:1000; letter-spacing:.2px; }
    .muted{ color:var(--muted); font-size:12px; }

    main{
      height: calc(100% - 58px);
      overflow:auto;
      padding: 0 14px calc(18px + var(--safe-b)) 14px;
      -webkit-overflow-scrolling: touch;
    }

    .card{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .spacer{ flex:1; }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight: 900;
      font-size:12px;
      color: var(--muted);
      white-space:nowrap;
    }

    input, textarea, button{ font:inherit; }
    textarea{
      width:100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,16,34,.55);
      color: var(--text);
      outline:none;
      min-height: 70px;
      resize: vertical;
    }
    .btn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 1000;
      cursor:pointer;
      user-select:none;
    }
    .btn.primary{ background: rgba(59,130,246,.20); border-color: rgba(59,130,246,.35); }
    .btn.danger{ background: rgba(239,68,68,.20); border-color: rgba(239,68,68,.35); }
    .btn.ok{ background: rgba(34,197,94,.18); border-color: rgba(34,197,94,.35); }
    .btn.sm{ padding: 8px 10px; border-radius: 10px; font-size: 12px; }
    .btn.icon{
      width:44px; height:44px;
      display:inline-flex; align-items:center; justify-content:center;
      padding:0; border-radius: 14px; font-size: 18px;
    }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    .drop{
      margin-top:10px;
      border:2px dashed rgba(255,255,255,.16);
      border-radius: var(--radius);
      padding: 12px;
      text-align:center;
      background: rgba(0,0,0,.10);
    }
    .drop.drag{ border-color: rgba(59,130,246,.85); background: rgba(59,130,246,.10); }

    .grid{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
    }
    @media (max-width: 1100px){ .grid{ grid-template-columns: repeat(4, 1fr); } }
    @media (max-width: 820px){ .grid{ grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 520px){ .grid{ grid-template-columns: repeat(2, 1fr); } }

    .thumb{
      position:relative;
      border-radius: 14px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      aspect-ratio: 1 / 1;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
      touch-action:none;
    }
    .thumb img{ width:100%; height:100%; object-fit:cover; display:block; }
    .num{
      position:absolute;
      top:8px; left:8px;
      padding: 6px 9px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 1000;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      z-index: 3;
    }

    .moveTag{
      position:absolute;
      top:8px; right:8px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 1100;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      z-index: 3;
      cursor: grab;
      user-select:none;
    }
    .moveTag:active{ cursor: grabbing; }

    .chipBar{
      position:absolute;
      left:8px; right:8px; bottom:8px;
      display:flex; justify-content:space-between; gap:8px;
      pointer-events:none;
      z-index: 3;
    }
    .chip{
      font-size:11px;
      padding: 5px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(12,18,38,.65);
      backdrop-filter: blur(10px);
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .ghost{
      position:fixed;
      z-index: 9999;
      pointer-events:none;
      opacity:.92;
      transform: scale(1.02);
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
    }
    .insertLine{
      position:absolute; top:0; bottom:0;
      width:0;
      border-left: 3px solid rgba(59,130,246,.95);
      filter: drop-shadow(0 0 10px rgba(59,130,246,.35));
      pointer-events:none;
      display:none;
      z-index: 2;
    }
    .insertBadge{
      position: sticky;
      top: 6px;
      z-index: 10;
      margin-top: 8px;
      display:none;
    }
    .insertBadgeInner{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.55);
      font-weight: 1100;
      font-size: 12px;
      max-width: 100%;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.72);
      backdrop-filter: blur(10px);
      z-index: 50;
      display:none;
    }
    .overlay.show{ display:block; }

    .viewer{
      position:absolute;
      inset: 10px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: var(--panel2);
      box-shadow: var(--shadow);
      display:flex;
      overflow:hidden;
    }
    .vLeft{
      flex: 1.55;
      position:relative;
      background: rgba(0,0,0,.18);
      min-width:0;
      touch-action:none;
    }
    canvas{ width:100%; height:100%; display:block; }
    .vRight{
      flex: 0.75;
      border-left:1px solid rgba(255,255,255,.10);
      padding:12px;
      overflow:auto;
      min-width: 300px;
    }
    @media (max-width: 950px){
      .viewer{ flex-direction:column; }
      .vRight{ border-left:none; border-top:1px solid rgba(255,255,255,.10); min-width:0; }
    }
    .topbar{
      position:absolute;
      top:10px; left:10px; right:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
      z-index: 10;
    }
    .topbar .group{ display:flex; gap:10px; pointer-events:auto; }

    .arrowBtn{
      position:absolute;
      top:50%;
      transform: translateY(-50%);
      width:54px; height:54px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center;
      font-size: 24px;
      font-weight: 1100;
      cursor:pointer;
      user-select:none;
      pointer-events:auto;
      z-index: 10;
    }
    .arrowBtn.left{ left:10px; }
    .arrowBtn.right{ right:10px; }
    .arrowBtn[aria-disabled="true"]{ opacity:.4; cursor:not-allowed; }

    .toolRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    .toolIcon{
      width:48px; height:48px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      cursor:pointer;
      user-select:none;
      display:flex; align-items:center; justify-content:center;
      font-weight:1100;
      font-size: 18px;
    }
    .toolIcon.active{
      background: rgba(59,130,246,.22);
      border-color: rgba(59,130,246,.40);
    }
    .hint{ color: var(--muted); font-size: 12px; margin-top: 8px; }
    .hr{ height:1px; background: rgba(255,255,255,.10); margin: 10px 0; }

    .toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom: calc(16px + var(--safe-b));
      background: rgba(0,0,0,.65);
      border:1px solid rgba(255,255,255,.12);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight:1100;
      font-size:12px;
      z-index: 60;
      display:none;
      max-width: 92vw;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .toast.show{ display:block; }
  </style>
</head>

<body>
<header>
  <div>
    <h1>Mitchell Teardown</h1>
    <div class="muted">Thumbnails ‚Üí click to edit ‚Üí ZIP matches edits exactly</div>
  </div>
  <div class="pill"><span id="hdrCount">0</span> photos</div>
</header>

<main>
  <section class="card">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div>
        <div style="font-weight:1100; font-size:16px;">Teardown</div>
        <div class="muted">Upload multiple photos ‚Ä¢ Reorder with MOVE ‚Ä¢ Drop shows IN FRONT / BEHIND ‚Ä¢ Auto-scroll while dragging</div>
      </div>
      <div class="pill" id="zipNamePill">ZIP: Mitchell_Teardown.zip</div>
    </div>

    <div class="row" style="margin-top:10px;">
      <label class="btn primary" style="display:inline-flex; align-items:center; gap:8px;">
        ‚¨ÜÔ∏è Upload Photos
        <input id="fileInput" type="file" accept="image/*" multiple hidden>
      </label>

      <button class="btn ok" id="exportZipBtn">Export ZIP (Mitchell Order)</button>
      <button class="btn danger" id="clearBtn">Clear All</button>
      <div class="spacer"></div>

      <input id="jobName" placeholder="Job name (RO12345_Smith)" style="
        min-width:240px; flex: 0 1 380px;
        padding: 10px 12px; border-radius: 12px;
        border:1px solid rgba(255,255,255,.14);
        background: rgba(10,16,34,.55);
        color: var(--text);
        outline:none;
        font-weight: 900;
      ">
    </div>

    <div class="drop" id="dropZone">
      <b>Drop photos here</b>
      <div class="muted">Reorder by grabbing MOVE on a photo.</div>
    </div>

    <div class="insertBadge" id="insertBadge">
      <div class="insertBadgeInner" id="insertBadgeInner">Dragging‚Ä¶</div>
    </div>
  </section>

  <div id="grid" class="grid"></div>
  <div id="empty" class="muted" style="text-align:center; padding: 22px 0; display:none;">
    No photos yet. Upload some above.
  </div>
</main>

<!-- VIEW/EDIT OVERLAY -->
<div class="overlay" id="overlay" aria-hidden="true">
  <div class="viewer">
    <div class="vLeft" id="vLeft">
      <div class="topbar">
        <div class="group">
          <button class="btn icon" id="closeBtn" title="Close">‚úï</button>
          <div class="pill" id="posPill">0 / 0</div>
        </div>
        <div class="group">
          <button class="btn icon" id="prevBtn" title="Prev">‚Üê</button>
          <button class="btn icon" id="nextBtn" title="Next">‚Üí</button>
        </div>
      </div>

      <div class="arrowBtn left" id="bigPrev" aria-disabled="false">‚Äπ</div>
      <div class="arrowBtn right" id="bigNext" aria-disabled="false">‚Ä∫</div>

      <canvas id="canvas"></canvas>
    </div>

    <div class="vRight">
      <div style="font-weight:1100; margin-bottom:4px;">EDIT (always on)</div>
      <div class="muted">Autosave ON ‚Ä¢ ZIP export is re-rendered from your saved edits (so it matches)</div>

      <div class="hr"></div>

      <div class="muted" style="margin-bottom:6px;">Notes (optional)</div>
      <textarea id="notesInput" placeholder="Damage notes‚Ä¶"></textarea>

      <div class="hr"></div>

      <div style="font-weight:1100;">Tools</div>
      <div class="toolRow" id="toolRow">
        <div class="toolIcon active" data-tool="arrow" title="Arrow">‚û§</div>
        <div class="toolIcon" data-tool="circle" title="Circle">‚óØ</div>
        <div class="toolIcon" data-tool="rect" title="Square">‚ñ¢</div>
        <div class="toolIcon" data-tool="line" title="Straight Line">Ôºè</div>
        <div class="toolIcon" data-tool="angle" title="Angle (2 lines)">‚à†</div>
        <div class="toolIcon" data-tool="ruler" title="Measure">üìè</div>
        <div class="toolIcon" data-tool="text" title="Add/Edit Text">T</div>
        <div class="toolIcon" data-tool="pan" title="Pan">‚úã</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn sm" id="undoBtn">Undo</button>
        <button class="btn sm" id="clearMarkupBtn">Clear Markup</button>
        <button class="btn sm" id="revertBtn">Revert Original</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn danger" id="deleteBtn">Delete Photo</button>
      </div>

      <div class="hint" id="angleHint" style="display:none;">
        Angle tool: draw <b>Line 1</b>, then draw <b>Line 2</b>. Angle label shows automatically.
      </div>
      <div class="hint" id="textHint" style="display:none;">
        Text tool: tap to place text (big). Tap existing green text to edit. Drag green text to move.
      </div>
      <div class="hint">Tip: Use ‚úã Pan to move around. (Zoom not included in this simple version.)</div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  // ======= Simple Teardown-only App =======
  const DB_NAME = "mitchell_teardown_simple_v1";
  const DB_VER  = 1;
  const STORE_ORIG  = "orig";   // {id, blob, type}
  const STORE_META  = "meta";   // {id, order, filename, created, notes, anno}
  const STORE_THUMB = "thumb";  // {id, blob}
  const STORE_EDIT  = "edit";   // {id, blob} (cached edited for thumbnails)
  const GREEN = "rgba(0,255,0,0.95)";
  const OUTLN = "rgba(0,0,0,0.75)";

  let db;
  let meta = [];  // current job list (Teardown only)
  let suppressClickUntil = 0;

  // reorder drag
  let dragCandidate = null;
  let dragging = null;
  let insertTarget = null;
  let autoScrollRAF = null;
  let autoScrollDir = 0;

  // viewer/editor
  const overlay = document.getElementById("overlay");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  let list = [];
  let idx = -1;
  let currentId = null;
  let baseBitmap = null;
  let view = { scale: 1, tx: 0, ty: 0 };
  let tool = "arrow";
  let isDown = false;
  let startW = {x:0,y:0};
  let tempShape = null;
  let anno = [];
  let undoStack = [];
  let angleStage = 0;

  // autosave
  let saveTimer = null;
  const AUTOSAVE_MS = 220;

  // UI
  const grid = document.getElementById("grid");
  const empty = document.getElementById("empty");
  const badgeWrap = document.getElementById("insertBadge");
  const badgeInner = document.getElementById("insertBadgeInner");
  const hdrCount = document.getElementById("hdrCount");
  const zipNamePill = document.getElementById("zipNamePill");
  const toastEl = document.getElementById("toast");
  let toastTimer = null;

  // Job name
  const LS_JOB = "mitchell_teardown_jobname";
  const jobNameEl = document.getElementById("jobName");
  jobNameEl.value = localStorage.getItem(LS_JOB) || "";
  jobNameEl.addEventListener("input", () => {
    localStorage.setItem(LS_JOB, jobNameEl.value || "");
    updateZipPill();
  });

  function updateZipPill(){
    const raw = (jobNameEl.value || "").trim();
    const safe = raw ? raw.replace(/[^\w\- ]+/g,"").replace(/\s+/g,"_") : "Teardown";
    zipNamePill.textContent = `ZIP: Mitchell_${safe}.zip`;
  }
  updateZipPill();

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove("show"), 1600);
  }

  function uuid(){
    return crypto.randomUUID ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2) + Date.now());
  }
  function nowISO(){ return new Date().toISOString(); }
  function pad3(n){ return String(n).padStart(3,"0"); }

  // ===== IndexedDB =====
  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VER);
      req.onerror = () => reject(req.error);
      req.onupgradeneeded = () => {
        const d = req.result;
        if (!d.objectStoreNames.contains(STORE_ORIG))  d.createObjectStore(STORE_ORIG,  {keyPath:"id"});
        if (!d.objectStoreNames.contains(STORE_META))  d.createObjectStore(STORE_META,  {keyPath:"id"});
        if (!d.objectStoreNames.contains(STORE_THUMB)) d.createObjectStore(STORE_THUMB, {keyPath:"id"});
        if (!d.objectStoreNames.contains(STORE_EDIT))  d.createObjectStore(STORE_EDIT,  {keyPath:"id"});
      };
      req.onsuccess = () => resolve(req.result);
    });
  }
  function tx(stores, mode="readonly"){ return db.transaction(stores, mode); }
  function idbGet(store, key){
    return new Promise((resolve, reject) => {
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function idbPut(store, val){
    return new Promise((resolve, reject) => {
      const req = store.put(val);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function idbDel(store, key){
    return new Promise((resolve, reject) => {
      const req = store.delete(key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  }
  function idbGetAll(store){
    return new Promise((resolve, reject) => {
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  }
  function waitTxDone(t){
    return new Promise((resolve, reject) => {
      t.oncomplete = () => resolve(true);
      t.onerror = () => reject(t.error);
      t.onabort = () => reject(t.error || new Error("tx aborted"));
    });
  }

  async function refreshMeta(){
    const all = await idbGetAll(tx([STORE_META],"readonly").objectStore(STORE_META));
    meta = all.map(m => ({
      id: m.id,
      order: Number.isFinite(m.order) ? m.order : 0,
      filename: m.filename || "photo.jpg",
      created: m.created || nowISO(),
      notes: m.notes || "",
      anno: Array.isArray(m.anno) ? m.anno : []
    }));
    meta.sort((a,b)=> (a.order||0)-(b.order||0));
    // normalize order 1..n
    meta.forEach((m,i)=> m.order = i+1);
    const t = tx([STORE_META],"readwrite");
    const s = t.objectStore(STORE_META);
    for (const m of meta){
      const cur = await idbGet(s, m.id);
      if (!cur) continue;
      await idbPut(s, {...cur, order: m.order});
    }
    await waitTxDone(t);
  }

  async function getThumbBlob(id){
    try{
      const t = tx([STORE_THUMB],"readonly");
      const rec = await idbGet(t.objectStore(STORE_THUMB), id);
      if (rec?.blob) return rec.blob;
    }catch{}
    try{
      const t = tx([STORE_EDIT],"readonly");
      const rec = await idbGet(t.objectStore(STORE_EDIT), id);
      if (rec?.blob) return rec.blob;
    }catch{}
    try{
      const t = tx([STORE_ORIG],"readonly");
      const rec = await idbGet(t.objectStore(STORE_ORIG), id);
      return rec?.blob || null;
    }catch{}
    return null;
  }

  async function ensureThumb(id){
    // already?
    try{
      const t = tx([STORE_THUMB],"readonly");
      const rec = await idbGet(t.objectStore(STORE_THUMB), id);
      if (rec?.blob) return;
    }catch{}
    const blob = await getThumbBlob(id);
    if (!blob) return;
    const bmp = await createImageBitmap(blob);
    const max = 360;
    const scale = Math.min(1, max / Math.max(bmp.width, bmp.height));
    const w = Math.max(1, Math.round(bmp.width * scale));
    const h = Math.max(1, Math.round(bmp.height * scale));
    const c = document.createElement("canvas");
    c.width=w; c.height=h;
    c.getContext("2d").drawImage(bmp,0,0,w,h);
    const thumbBlob = await new Promise(res=>c.toBlob(res,"image/jpeg",0.85));
    if (!thumbBlob) return;
    const t2 = tx([STORE_THUMB],"readwrite");
    await idbPut(t2.objectStore(STORE_THUMB), {id, blob: thumbBlob});
    await waitTxDone(t2);
  }

  // ===== Add photos =====
  async function addFiles(files){
    await refreshMeta();
    const maxOrder = meta.reduce((mx,m)=>Math.max(mx,m.order||0),0);
    const t = tx([STORE_ORIG, STORE_META], "readwrite");
    const sO = t.objectStore(STORE_ORIG);
    const sM = t.objectStore(STORE_META);
    let added = 0;
    for (const f of files){
      if (!f.type.startsWith("image/")) continue;
      const id = uuid();
      await idbPut(sO, {id, blob: f, type: f.type || "image/jpeg"});
      await idbPut(sM, {
        id,
        order: maxOrder + added + 1,
        filename: f.name || `TEARDOWN_${pad3(maxOrder+added+1)}.JPG`,
        created: nowISO(),
        notes: "",
        anno: []
      });
      added++;
    }
    await waitTxDone(t);
    await refreshMeta();
    // thumbs
    for (const m of meta.slice(-added)) await ensureThumb(m.id);
    toast(`Added ${added} photo(s).`);
    renderGrid();
  }

  // ===== Grid render =====
  async function renderGrid(){
    await refreshMeta();
    hdrCount.textContent = String(meta.length);
    grid.innerHTML = "";
    badgeWrap.style.display = "none";
    empty.style.display = meta.length ? "none" : "";

    meta.forEach((m, i) => {
      const div = document.createElement("div");
      div.className = "thumb";
      div.dataset.id = m.id;
      div.dataset.index = String(i);

      const img = document.createElement("img");
      div.appendChild(img);

      const num = document.createElement("div");
      num.className = "num";
      num.textContent = String(i+1);
      div.appendChild(num);

      const move = document.createElement("div");
      move.className = "moveTag";
      move.textContent = "MOVE";
      move.title = "Hold and drag to reorder";
      div.appendChild(move);

      const bar = document.createElement("div");
      bar.className = "chipBar";
      bar.innerHTML = `<span class="chip">Teardown</span><span class="chip">${pad3(i+1)}</span>`;
      div.appendChild(bar);

      const insertLine = document.createElement("div");
      insertLine.className = "insertLine";
      div.appendChild(insertLine);

      // click to open (but not right after dragging)
      div.addEventListener("click", () => {
        if (Date.now() < suppressClickUntil) return;
        openViewer(i);
      });

      // Only allow reorder by grabbing MOVE
      move.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        beginDrag(e, div, i);
      });

      grid.appendChild(div);

      getThumbBlob(m.id).then(blob => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        img.src = url;
        img.onload = () => URL.revokeObjectURL(url);
      });
    });
  }

  // ===== Drag reorder =====
  function beginDrag(e, el, fromIndex){
    const r = el.getBoundingClientRect();
    const offsetX = e.clientX - r.left;
    const offsetY = e.clientY - r.top;

    const ghost = el.cloneNode(true);
    ghost.classList.add("ghost");
    ghost.style.left = (e.clientX - offsetX) + "px";
    ghost.style.top  = (e.clientY - offsetY) + "px";
    ghost.style.width  = r.width + "px";
    ghost.style.height = r.height + "px";
    document.body.appendChild(ghost);

    dragging = { id: el.dataset.id, fromIndex, ghost, offsetX, offsetY };
    insertTarget = null;

    badgeWrap.style.display = "";
    badgeInner.textContent = "Dragging‚Ä¶";

    const move = (ev)=> onDragMove(ev);
    const up   = (ev)=> onDragEnd(ev, move, up);
    window.addEventListener("pointermove", move, {passive:false});
    window.addEventListener("pointerup", up, {passive:false});
  }

  function clearInsertIndicators(){
    grid.querySelectorAll(".insertLine").forEach(l => l.style.display = "none");
  }

  function tryAutoScroll(clientY){
    const margin = 70;
    const top = 58 + 10;
    const bottom = window.innerHeight - 20;
    if (clientY < top + margin) autoScrollDir = -1;
    else if (clientY > bottom - margin) autoScrollDir = 1;
    else autoScrollDir = 0;

    if (autoScrollDir !== 0 && !autoScrollRAF){
      const step = () => {
        if (!autoScrollDir){ autoScrollRAF = null; return; }
        document.querySelector("main").scrollTop += autoScrollDir * 18;
        autoScrollRAF = requestAnimationFrame(step);
      };
      autoScrollRAF = requestAnimationFrame(step);
    }
    if (autoScrollDir === 0 && autoScrollRAF){
      cancelAnimationFrame(autoScrollRAF);
      autoScrollRAF = null;
    }
  }
  function stopAutoScroll(){
    autoScrollDir = 0;
    if (autoScrollRAF){ cancelAnimationFrame(autoScrollRAF); autoScrollRAF = null; }
  }

  function onDragMove(e){
    if (!dragging) return;
    e.preventDefault();
    tryAutoScroll(e.clientY);

    dragging.ghost.style.left = (e.clientX - dragging.offsetX) + "px";
    dragging.ghost.style.top  = (e.clientY - dragging.offsetY) + "px";

    const thumbs = Array.from(grid.querySelectorAll(".thumb"));
    let hit = null;
    for (const t of thumbs){
      const r = t.getBoundingClientRect();
      if (e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom){
        hit = { el:t, rect:r, index:Number(t.dataset.index) };
        break;
      }
    }

    clearInsertIndicators();
    insertTarget = null;

    if (!hit){
      badgeInner.textContent = "Move to a position‚Ä¶";
      return;
    }

    const midX = (hit.rect.left + hit.rect.right) / 2;
    const side = (e.clientX < midX) ? "before" : "after";

    const line = hit.el.querySelector(".insertLine");
    line.style.display = "block";
    line.style.left = (side === "before") ? "8px" : "calc(100% - 8px)";

    insertTarget = { index: hit.index, side };
    const placeNum = hit.index + 1;
    badgeInner.textContent = side === "before"
      ? `Place BEFORE #${placeNum} (IN FRONT)`
      : `Place AFTER #${placeNum} (BEHIND)`;
  }

  async function onDragEnd(e, moveHandler, upHandler){
    window.removeEventListener("pointermove", moveHandler);
    window.removeEventListener("pointerup", upHandler);

    if (!dragging) return;
    e.preventDefault();

    stopAutoScroll();
    clearInsertIndicators();
    badgeWrap.style.display = "none";

    dragging.ghost.remove();

    suppressClickUntil = Date.now() + 350;

    await refreshMeta();
    let from = dragging.fromIndex;
    let to = from;

    if (insertTarget){
      to = insertTarget.index + (insertTarget.side === "after" ? 1 : 0);
      if (to > from) to -= 1;
    }

    const n = meta.length;
    to = Math.max(0, Math.min(to, n-1));
    if (to !== from){
      const arr = meta.slice();
      const item = arr.splice(from,1)[0];
      arr.splice(to,0,item);
      arr.forEach((m,i)=> m.order = i+1);

      const t = tx([STORE_META],"readwrite");
      const s = t.objectStore(STORE_META);
      for (const m of arr){
        const cur = await idbGet(s, m.id);
        if (!cur) continue;
        await idbPut(s, {...cur, order: m.order});
      }
      await waitTxDone(t);
      toast(`Moved to #${to+1}`);
    }

    dragging = null;
    insertTarget = null;

    await renderGrid();
  }

  // ===== Drop zone + file input =====
  const fileInput = document.getElementById("fileInput");
  fileInput.addEventListener("change", async (e) => {
    const files = Array.from(e.target.files || []);
    e.target.value = "";
    if (files.length) await addFiles(files);
  });

  const dropZone = document.getElementById("dropZone");
  ["dragenter","dragover"].forEach(ev => dropZone.addEventListener(ev, (e) => {
    e.preventDefault(); e.stopPropagation();
    dropZone.classList.add("drag");
  }));
  ["dragleave","drop"].forEach(ev => dropZone.addEventListener(ev, (e) => {
    e.preventDefault(); e.stopPropagation();
    dropZone.classList.remove("drag");
  }));
  dropZone.addEventListener("drop", async (e) => {
    const files = Array.from(e.dataTransfer.files || []).filter(f => f.type.startsWith("image/"));
    if (files.length) await addFiles(files);
  });

  // ===== Clear all =====
  document.getElementById("clearBtn").addEventListener("click", async () => {
    if (!confirm("Clear ALL photos on this device?")) return;
    await new Promise((resolve) => {
      const req = indexedDB.deleteDatabase(DB_NAME);
      req.onsuccess = resolve;
      req.onerror = resolve;
      req.onblocked = resolve;
    });
    db = await openDB();
    meta = [];
    toast("Cleared.");
    renderGrid();
  });

  // ===== Viewer/editor open/close/nav =====
  function resizeCanvasToContainer(){
    const host = document.getElementById("vLeft").getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(host.width * dpr);
    canvas.height = Math.floor(host.height * dpr);
    canvas.style.width = host.width + "px";
    canvas.style.height = host.height + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function resetView(){
    view.tx = 0; view.ty = 0; view.scale = 1;
    if (!baseBitmap) return;
    const cw = canvas.clientWidth, ch = canvas.clientHeight;
    const iw = baseBitmap.width, ih = baseBitmap.height;
    const s = Math.min(cw/iw, ch/ih);
    view.scale = s;
    view.tx = (cw - iw*s)/2;
    view.ty = (ch - ih*s)/2;
  }
  function pointerPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }
  function screenToWorld(x,y){
    return { x: (x - view.tx) / view.scale, y: (y - view.ty) / view.scale };
  }

  async function loadOriginalBitmap(id){
    const t = tx([STORE_ORIG],"readonly");
    const rec = await idbGet(t.objectStore(STORE_ORIG), id);
    if (!rec?.blob){ baseBitmap = null; return; }
    baseBitmap = await createImageBitmap(rec.blob);
    resizeCanvasToContainer();
  }

  function setArrows(){
    const canPrev = idx > 0;
    const canNext = idx < list.length - 1;
    document.getElementById("prevBtn").disabled = !canPrev;
    document.getElementById("nextBtn").disabled = !canNext;
    document.getElementById("bigPrev").setAttribute("aria-disabled", canPrev ? "false" : "true");
    document.getElementById("bigNext").setAttribute("aria-disabled", canNext ? "false" : "true");
  }

  async function openViewer(i){
    await refreshMeta();
    list = meta.slice();
    idx = Math.max(0, Math.min(i, list.length-1));
    currentId = list[idx]?.id || null;
    if (!currentId) return;

    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden","false");
    document.getElementById("posPill").textContent = `${idx+1} / ${list.length}`;

    const m = list[idx];
    anno = Array.isArray(m.anno) ? structuredClone(m.anno) : [];
    undoStack = [];
    angleStage = 0;
    document.getElementById("notesInput").value = m.notes || "";

    await loadOriginalBitmap(currentId);
    resetView();
    redraw();
    setArrows();
    setHints();
  }

  function closeViewer(){
    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden","true");
    baseBitmap = null;
    list = [];
    idx = -1;
    currentId = null;
    anno = [];
    undoStack = [];
    angleStage = 0;
    tempShape = null;
    clearTimeout(saveTimer);
    saveTimer = null;
  }

  async function step(dir){
    const next = idx + dir;
    if (next < 0 || next >= list.length) return;
    await flushAutosave();
    await openViewer(next);
  }

  document.getElementById("closeBtn").addEventListener("click", async ()=>{ await flushAutosave(); closeViewer(); });
  document.getElementById("prevBtn").addEventListener("click", ()=>step(-1));
  document.getElementById("nextBtn").addEventListener("click", ()=>step(+1));
  document.getElementById("bigPrev").addEventListener("click", ()=>step(-1));
  document.getElementById("bigNext").addEventListener("click", ()=>step(+1));
  document.addEventListener("keydown", async (e)=>{
    if (!overlay.classList.contains("show")) return;
    if (e.key === "Escape"){ await flushAutosave(); closeViewer(); }
    if (e.key === "ArrowLeft") step(-1);
    if (e.key === "ArrowRight") step(+1);
  });

  // ===== Tools + drawing =====
  function setTool(next){
    tool = next;
    document.querySelectorAll(".toolIcon").forEach(el => el.classList.toggle("active", el.dataset.tool === tool));
    angleStage = 0;
    setHints();
  }
  function setHints(){
    document.getElementById("angleHint").style.display = (tool==="angle") ? "" : "none";
    document.getElementById("textHint").style.display = (tool==="text") ? "" : "none";
  }
  document.getElementById("toolRow").addEventListener("click",(e)=>{
    const t = e.target.closest(".toolIcon");
    if (!t) return;
    setTool(t.dataset.tool);
  });

  function pushUndo(){
    undoStack.push(structuredClone(anno));
    if (undoStack.length > 60) undoStack.shift();
  }

  // ===== Render: screen + export use SAME math, export scales bigger =====
  function computeExportSF(w,h){
    const longSide = Math.max(w,h) || 1200;
    return Math.max(0.9, Math.min(3.0, longSide / 1200));
  }

  function roundRectPath(c, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  function drawLabel(c, txt, x, y, fontPx, lw){
    c.save();
    c.setLineDash([]);
    c.font = `${fontPx}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial`;
    c.fillStyle = GREEN;
    c.strokeStyle = OUTLN;
    c.lineWidth = lw;
    c.strokeText(txt, x, y);
    c.fillText(txt, x, y);
    c.restore();
  }

  function drawShapes(c, shapes, mode, baseW, baseH, dashed=false){
    // mode: "screen" (world coords + view transform) or "export" (raw image coords)
    const sf = (mode==="export") ? computeExportSF(baseW, baseH) : 1;

    const strokeW = (mode==="export") ? (8*sf) : 4;
    const outlineW = (mode==="export") ? (strokeW + 4*sf) : (strokeW + 2);

    const arrowHead = (mode==="export") ? (90*sf) : (18 / view.scale);
    const labelFont = (mode==="export") ? (36*sf) : (14 / view.scale);

    const textFont = (mode==="export") ? (62*sf) : 30;   // BIG on screen
    const textPad  = (mode==="export") ? (22*sf) : 12;
    const textRad  = (mode==="export") ? (18*sf) : 10;

    const needsView = (mode==="screen");

    function drawOne(s, color, lw, isOutline){
      if (s.type === "text"){
        c.save();
        if (needsView){ c.translate(view.tx, view.ty); c.scale(view.scale, view.scale); }
        c.font = `${textFont}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial`;
        const lines = (s.text||"").split("\n");
        const lineH = textFont * 1.2;
        let maxW = 0;
        for (const line of lines) maxW = Math.max(maxW, c.measureText(line).width);
        const w = Math.max(120, maxW + textPad*2);
        const h = Math.max(70, lines.length*lineH + textPad*2);
        s.w = w; s.h = h;

        if (!isOutline){
          c.fillStyle = GREEN;
          roundRectPath(c, s.x, s.y, w, h, textRad);
          c.fill();
          c.strokeStyle = "rgba(0,0,0,0.92)";
          c.lineWidth = Math.max(3, (mode==="export") ? 8*sf : 3);
          c.stroke();
          c.fillStyle = "rgba(0,0,0,1)";
          c.textAlign = "center";
          c.textBaseline = "middle";
          const cx = s.x + w/2, cy = s.y + h/2;
          const totalH = lines.length*lineH;
          let yy = cy - totalH/2 + lineH/2;
          for (const line of lines){
            c.fillText(line, cx, yy);
            yy += lineH;
          }
        }
        c.restore();
        return;
      }

      c.save();
      if (needsView){ c.translate(view.tx, view.ty); c.scale(view.scale, view.scale); }
      c.strokeStyle = color;
      c.lineWidth = lw / (needsView ? view.scale : 1);
      c.lineCap = "round";
      c.lineJoin = "round";
      c.setLineDash(dashed ? [12,10] : []);

      if (["line","ruler","angleLine"].includes(s.type)){
        c.beginPath();
        c.moveTo(s.x1,s.y1);
        c.lineTo(s.x2,s.y2);
        c.stroke();

        if (s.type === "ruler" && !isOutline){
          const len = Math.hypot(s.x2-s.x1, s.y2-s.y1);
          drawLabel(c, `${len.toFixed(0)} px`, (s.x1+s.x2)/2 + 16, (s.y1+s.y2)/2 - 16, labelFont, Math.max(3,(mode==="export")?10*sf:(5/view.scale)));
        }
      } else if (s.type === "rect"){
        const x = Math.min(s.x1,s.x2), y = Math.min(s.y1,s.y2);
        const w = Math.abs(s.x2-s.x1), h = Math.abs(s.y2-s.y1);
        c.strokeRect(x,y,w,h);
      } else if (s.type === "circle"){
        const cx = (s.x1+s.x2)/2, cy = (s.y1+s.y2)/2;
        const rx = Math.abs(s.x2-s.x1)/2, ry = Math.abs(s.y2-s.y1)/2;
        c.beginPath();
        if (c.ellipse) c.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
        else {
          c.save(); c.translate(cx,cy); c.scale(rx||1, ry||1);
          c.arc(0,0,1,0,Math.PI*2);
          c.restore();
        }
        c.stroke();
      } else if (s.type === "arrow"){
        c.beginPath();
        c.moveTo(s.x1,s.y1);
        c.lineTo(s.x2,s.y2);
        c.stroke();

        const dx = s.x2-s.x1, dy = s.y2-s.y1;
        const ang = Math.atan2(dy,dx);
        const headLen = arrowHead;
        const a1 = ang - Math.PI/8;
        const a2 = ang + Math.PI/8;

        c.beginPath();
        c.moveTo(s.x2,s.y2);
        c.lineTo(s.x2 - Math.cos(a1)*headLen, s.y2 - Math.sin(a1)*headLen);
        c.moveTo(s.x2,s.y2);
        c.lineTo(s.x2 - Math.cos(a2)*headLen, s.y2 - Math.sin(a2)*headLen);
        c.stroke();
      }
      c.restore();
    }

    // outlines first, then green
    for (const s of shapes) drawOne(s, OUTLN, outlineW, true);
    for (const s of shapes) drawOne(s, GREEN, strokeW, false);

    // angle label (last)
    const lines = shapes.filter(s=>s.type==="angleLine");
    if (lines.length >= 2){
      const l2 = lines[lines.length-1];
      const l1 = lines[lines.length-2];
      const a = {x: l1.x2-l1.x1, y:l1.y2-l1.y1};
      const b = {x: l2.x2-l2.x1, y:l2.y2-l2.y1};
      const dot = a.x*b.x + a.y*b.y;
      const la = Math.hypot(a.x,a.y), lb = Math.hypot(b.x,b.y);
      if (la && lb){
        const deg = Math.acos(Math.max(-1, Math.min(1, dot/(la*lb)))) * 180/Math.PI;

        c.save();
        if (needsView){ c.translate(view.tx, view.ty); c.scale(view.scale, view.scale); }
        drawLabel(c, `${deg.toFixed(1)}¬∞`, l2.x1 + 18, l2.y1 - 18, labelFont, Math.max(3,(mode==="export")?10*sf:(5/view.scale)));
        c.restore();
      }
    }
  }

  function redraw(){
    resizeCanvasToContainer();
    const cw = canvas.clientWidth, ch = canvas.clientHeight;
    ctx.clearRect(0,0,cw,ch);

    if (baseBitmap){
      ctx.save();
      ctx.translate(view.tx, view.ty);
      ctx.scale(view.scale, view.scale);
      ctx.drawImage(baseBitmap, 0, 0);
      ctx.restore();
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(0,0,cw,ch);
    }

    drawShapes(ctx, anno, "screen", baseBitmap?.width||1200, baseBitmap?.height||900, false);
    if (tempShape) drawShapes(ctx, [tempShape], "screen", baseBitmap?.width||1200, baseBitmap?.height||900, true);
  }

  // ===== Text select/move/edit =====
  function pointInText(s, p){
    if (s.type !== "text") return false;
    const w = s.w || 0, h = s.h || 0;
    return p.x >= s.x && p.x <= s.x + w && p.y >= s.y && p.y <= s.y + h;
  }
  function topmostTextAt(p){
    for (let i=anno.length-1; i>=0; i--){
      const s = anno[i];
      if (s.type==="text" && pointInText(s,p)) return {shape:s, index:i};
    }
    return null;
  }
  let movingText = null;

  // ===== Autosave (meta + cached edited blob + thumb) =====
  function scheduleAutosave(){
    clearTimeout(saveTimer);
    saveTimer = setTimeout(()=>autosave().catch(console.error), AUTOSAVE_MS);
  }
  async function flushAutosave(){
    if (saveTimer){
      clearTimeout(saveTimer);
      saveTimer = null;
      await autosave();
    }
  }
  async function persistMetaPatch(id, patch){
    const t = tx([STORE_META],"readwrite");
    const s = t.objectStore(STORE_META);
    const cur = await idbGet(s, id);
    if (!cur){ t.abort(); return; }
    await idbPut(s, {...cur, ...patch});
    await waitTxDone(t);
  }

  async function renderEditedBlobFromAnno(id, shapes){
    const tO = (tx([STORE_ORIG],"readonly")).objectStore(STORE_ORIG);
    const rec = await idbGet(tO, id);
    if (!rec?.blob) return null;
    const bmp = await createImageBitmap(rec.blob);

    const w = bmp.width, h = bmp.height;
    const off = document.createElement("canvas");
    off.width = w; off.height = h;
    const o = off.getContext("2d");
    o.drawImage(bmp,0,0);
    drawShapes(o, structuredClone(shapes||[]), "export", w, h, false);

    const out = await new Promise(res=>off.toBlob(res,"image/jpeg",0.92));
    return out || null;
  }

  async function autosave(){
    if (!currentId) return;
    const notes = document.getElementById("notesInput").value || "";
    await persistMetaPatch(currentId, { notes, anno: structuredClone(anno) });

    // cache edited image for fast thumbnails (optional but helpful)
    if (baseBitmap){
      const editedBlob = await renderEditedBlobFromAnno(currentId, anno);
      if (editedBlob){
        const t = tx([STORE_EDIT],"readwrite");
        await idbPut(t.objectStore(STORE_EDIT), {id: currentId, blob: editedBlob});
        await waitTxDone(t);

        // thumb from edited
        const bmp = await createImageBitmap(editedBlob);
        const max = 360;
        const scale = Math.min(1, max / Math.max(bmp.width, bmp.height));
        const tw = Math.max(1, Math.round(bmp.width * scale));
        const th = Math.max(1, Math.round(bmp.height * scale));
        const tc = document.createElement("canvas");
        tc.width=tw; tc.height=th;
        tc.getContext("2d").drawImage(bmp,0,0,tw,th);
        const thumbBlob = await new Promise(res=>tc.toBlob(res,"image/jpeg",0.85));
        if (thumbBlob){
          const t2 = tx([STORE_THUMB],"readwrite");
          await idbPut(t2.objectStore(STORE_THUMB), {id: currentId, blob: thumbBlob});
          await waitTxDone(t2);
        }
      }
    }

    // update grid thumbs
    renderGrid();
  }

  // ===== Canvas interactions =====
  canvas.addEventListener("pointerdown", (e)=>{
    if (!baseBitmap) return;
    canvas.setPointerCapture(e.pointerId);
    isDown = true;

    const p = pointerPos(e);
    const w = screenToWorld(p.x, p.y);

    // text hit?
    const hit = topmostTextAt(w);
    if (hit){
      movingText = { index: hit.index, dx: w.x - hit.shape.x, dy: w.y - hit.shape.y };
      tempShape = null;
      redraw();
      return;
    }

    startW = w;
    tempShape = null;

    if (tool==="pan"){
      startW._sx = p.x; startW._sy = p.y;
      startW._tx = view.tx; startW._ty = view.ty;
    }
  });

  canvas.addEventListener("pointermove", (e)=>{
    if (!isDown || !baseBitmap) return;
    const p = pointerPos(e);

    if (movingText){
      const w = screenToWorld(p.x, p.y);
      const s = anno[movingText.index];
      if (s && s.type==="text"){
        s.x = w.x - movingText.dx;
        s.y = w.y - movingText.dy;
        redraw();
        scheduleAutosave();
      }
      return;
    }

    if (tool==="pan"){
      const dx = p.x - (startW._sx||0);
      const dy = p.y - (startW._sy||0);
      view.tx = (startW._tx||0) + dx;
      view.ty = (startW._ty||0) + dy;
      redraw();
      return;
    }

    const w = screenToWorld(p.x,p.y);

    if (tool==="rect") tempShape = {type:"rect", x1:startW.x, y1:startW.y, x2:w.x, y2:w.y};
    else if (tool==="circle") tempShape = {type:"circle", x1:startW.x, y1:startW.y, x2:w.x, y2:w.y};
    else if (tool==="line") tempShape = {type:"line", x1:startW.x, y1:startW.y, x2:w.x, y2:w.y};
    else if (tool==="arrow") tempShape = {type:"arrow", x1:startW.x, y1:startW.y, x2:w.x, y2:w.y};
    else if (tool==="ruler") tempShape = {type:"ruler", x1:startW.x, y1:startW.y, x2:w.x, y2:w.y};
    else if (tool==="angle") tempShape = {type:"angleLine", x1:startW.x, y1:startW.y, x2:w.x, y2:w.y};

    redraw();
  });

  canvas.addEventListener("pointerup", (e)=>{
    if (!isDown) return;
    isDown = false;

    if (movingText){
      movingText = null;
      return;
    }

    if (tool==="pan"){ tempShape = null; return; }

    if (tool==="text"){
      // tap existing text edits, otherwise add
      const p = pointerPos(e);
      const w = screenToWorld(p.x, p.y);
      const hit = topmostTextAt(w);
      if (hit){
        const next = prompt("Edit text:", hit.shape.text || "");
        if (next != null){
          pushUndo();
          hit.shape.text = next.trim();
          redraw();
          scheduleAutosave();
        }
        return;
      }
      const content = prompt("Text:", "ADD NOTE");
      if (content && content.trim()){
        pushUndo();
        // drop near center if empty tap? (use tap position)
        anno.push({type:"text", x:w.x, y:w.y, text: content.trim(), w:0, h:0});
        redraw();
        scheduleAutosave();
      }
      return;
    }

    if (!tempShape) return;

    if (tool !== "angle"){
      pushUndo();
      anno.push(tempShape);
      tempShape = null;
      redraw();
      scheduleAutosave();
      return;
    }

    // angle: needs 2 lines
    if (angleStage === 0){
      pushUndo();
      anno.push(structuredClone(tempShape));
      angleStage = 1;
      tempShape = null;
      redraw();
      scheduleAutosave();
    } else {
      pushUndo();
      anno.push(structuredClone(tempShape));
      angleStage = 0;
      tempShape = null;
      redraw();
      scheduleAutosave();
    }
  });

  // ===== Notes autosave =====
  document.getElementById("notesInput").addEventListener("input", scheduleAutosave);

  // ===== Undo/Clear/Revert/Delete =====
  document.getElementById("undoBtn").addEventListener("click", ()=>{
    if (!undoStack.length) return;
    anno = undoStack.pop();
    angleStage = 0;
    redraw();
    scheduleAutosave();
  });
  document.getElementById("clearMarkupBtn").addEventListener("click", ()=>{
    if (!anno.length) return;
    if (!confirm("Clear all markup on this photo?")) return;
    pushUndo();
    anno = [];
    angleStage = 0;
    redraw();
    scheduleAutosave();
  });

  async function revertToOriginal(){
    if (!currentId) return;
    if (!confirm("Revert this photo back to ORIGINAL (remove all edits/markup)?")) return;
    anno = [];
    undoStack = [];
    angleStage = 0;

    // remove caches
    const t = tx([STORE_EDIT, STORE_THUMB], "readwrite");
    await idbDel(t.objectStore(STORE_EDIT), currentId).catch(()=>{});
    await idbDel(t.objectStore(STORE_THUMB), currentId).catch(()=>{});
    await waitTxDone(t);

    await persistMetaPatch(currentId, { anno: [], notes: document.getElementById("notesInput").value || "" });
    await ensureThumb(currentId);

    redraw();
    toast("Reverted.");
    renderGrid();
  }
  document.getElementById("revertBtn").addEventListener("click", ()=>revertToOriginal().catch(console.error));

  async function deleteCurrent(){
    if (!currentId) return;
    if (!confirm("Delete this photo?")) return;

    const id = currentId;

    const t = tx([STORE_ORIG, STORE_META, STORE_THUMB, STORE_EDIT], "readwrite");
    await idbDel(t.objectStore(STORE_ORIG), id).catch(()=>{});
    await idbDel(t.objectStore(STORE_META), id).catch(()=>{});
    await idbDel(t.objectStore(STORE_THUMB), id).catch(()=>{});
    await idbDel(t.objectStore(STORE_EDIT), id).catch(()=>{});
    await waitTxDone(t);

    await refreshMeta();
    toast("Deleted.");
    if (!meta.length){
      closeViewer();
      renderGrid();
      return;
    }
    const nextIndex = Math.min(idx, meta.length-1);
    closeViewer();
    await renderGrid();
    openViewer(nextIndex);
  }
  document.getElementById("deleteBtn").addEventListener("click", ()=>deleteCurrent().catch(console.error));

  // ===== ZIP Export (THE IMPORTANT PART) =====
  function downloadBlob(filename, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function exportZip(){
    if (!window.JSZip){
      alert("JSZip failed to load (offline?). Connect once and try again.");
      return;
    }

    await flushAutosave();
    await refreshMeta();

    const zip = new JSZip();

    for (let i=0; i<meta.length; i++){
      const m = meta[i];

      // KEY: Re-render from ORIGINAL + SAVED ANNO right now,
      // so ZIP image is EXACTLY like the edited one.
      const editedBlob = await renderEditedBlobFromAnno(m.id, m.anno);
      if (editedBlob){
        zip.file(`TEARDOWN_${pad3(i+1)}.JPG`, editedBlob);
      } else {
        // fallback to original
        const tO = tx([STORE_ORIG],"readonly");
        const rec = await idbGet(tO.objectStore(STORE_ORIG), m.id);
        if (rec?.blob) zip.file(`TEARDOWN_${pad3(i+1)}.JPG`, rec.blob);
      }
    }

    const raw = (jobNameEl.value || "").trim();
    const safe = raw ? raw.replace(/[^\w\- ]+/g,"").replace(/\s+/g,"_") : "Teardown";
    const fileName = `Mitchell_${safe}.zip`;

    toast("Building ZIP‚Ä¶");
    const out = await zip.generateAsync({type:"blob"});
    downloadBlob(fileName, out);
    toast("ZIP downloaded.");
  }
  document.getElementById("exportZipBtn").addEventListener("click", ()=>exportZip().catch(console.error));

  // ===== Init =====
  async function init(){
    db = await openDB();
    await renderGrid();
  }
  init().catch(err => { console.error(err); toast("Failed to load."); });
})();
</script>
</body>
</html>
